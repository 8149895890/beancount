/* -*- mode: c++ -*- */
// Parser grammar for beancount 3.0 input syntax (Bison C++).

//- Options -------------------------------------------------------------------

%require "3.7"

%language "c++"
%define api.namespace {beancount::parser}
%define api.parser.class {Parser}
%define parse.error detailed
%define parse.trace

// %verbose, have to specify the output file.
// %token-table // Has no effect on C++ code generation.

%defines
%locations
%define api.filename.type "const std::string"

// %initial-action does not work to set the filename since the location() is set
// on the symbol itself.
// This doesn't work either.
// %initial-action {
//   driver.WithLocation(@$);
// }

// Input state to parser.
%parse-param {::beancount::scanner::Scanner& scanner} {::beancount::parser::Builder& builder}

//- Code blocks ---------------------------------------------------------------

// Inserted in header, before anything else
%code requires {

#include "beancount/cparser/parser.pb.h"
#include "beancount/ccore/data.pb.h"
#include "beancount/ccore/number.pb.h"

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <cstdint>
#include <cstdio>
#include <fstream>
#include <list>
#include <memory>
#include <string>
#include <optional>

#include "absl/strings/string_view.h"
#include "absl/time/civil_time.h"

#include "decimal.hh"

namespace beancount {
namespace scanner { class Scanner; }
namespace parser {
class Builder;

// Parse the contents of a file.
void ParseFile(PyObject* builder_obj,
               const std::string_view& filename,
               PyObject* missing_obj);

}  // namespace parser
}  // namespace beancount
}  // %code requires

// Inserted in header, at the end.
%code provides {
}  // %code provides

//-----------------------------------------------------------------------------
// Inserted in implementation after including parser header.
%code top {

#include "beancount/cparser/scanner.h"  /* Generated by reflex. */
#include "beancount/parser/macros.h"
#include "beancount/parser/tokens.h"
#include "beancount/ccore/number.h"

#include <iostream>
#include <list>
#include <string>
#include <unordered_map>
#include <utility>

#include "absl/container/flat_hash_map.h"
#include "absl/container/flat_hash_set.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/str_format.h"
#include "absl/strings/string_view.h"
#include "reflex/input.h"

using std::string_view;
using std::cerr;
using std::cout;
using std::endl;
using std::list;
using std::pair;
using std::string;
using std::unique_ptr;
using std::vector;
using absl::StrFormat;

namespace beancount {
namespace parser {

// Default and only encoding we really have to bother supporting.
// TODO(blais): Revise this later, maybe make it part of the state of the builder.
static const char* kEncoding = "UTF-8";

// Convert string_view to Python string object.
inline PyObject* StringToPyString(const string_view s) {
  return PyUnicode_Decode(s.data(), s.size(), kEncoding, "ignore");
}

// Convert absl::CivilDay to Python date object.
inline PyObject* DateToPyDate(const absl::CivilDay& d) {
  return pydate_from_civil_day(d.year(), d.month(), d.day());
}

// Convert a decimal::Decimal to a PyDecimal.
inline PyObject* DecimalToPyDecimal(const decimal::Decimal& d) {
  return pydecimal_from_cstring(d.to_sci().c_str());
}

// Convert a date object to an equivalent proto.
inline void DateToProto(const absl::CivilDay& date, Date* proto) {
  assert(proto != nullptr);
  proto->set_year(date.year());
  proto->set_month(date.month());
  proto->set_day(date.day());
}

// Create two sets from a TagsLinks object.
std::tuple<PyObject*, PyObject*> TagsLinksToPython(
  inter::TagsLinks* tags_links,
  const absl::flat_hash_set<string>* active_tags) {

  assert(tags_links != nullptr);
  PyObject* tags = PySet_New(0);
  for (const auto& tag : tags_links->tags()) {
    PySet_Add(tags, StringToPyString(tag));
  }
  PyObject* links = PySet_New(0);
  for (const auto& link : tags_links->links()) {
    PySet_Add(links, StringToPyString(link));
  }

  // Add the set of active tags if provided.
  if (active_tags != nullptr) {
    for (const auto& tag : *active_tags) {
      PySet_Add(tags, StringToPyString(tag));
    }
  }

  return {tags, links};
}

/*
 * Call a builder method and detect and handle a Python exception being raised
 * in the handler. Always run the code to clean the references provided by the
 * reduced rule. {05bb0fb60e86}
 */
#define BUILDY(clean, target, method_name, format, ...)                                         \
  {                                                                                             \
    auto loc = scanner.location();                                                              \
    /* cerr << "method_name: " << method_name << endl */                                        \
    /*     << "filename: " << *loc.begin.filename << ":" << loc.begin.line << endl; */          \
    target = PyObject_CallMethod(builder.builder(), method_name, "si" format,                   \
                                 loc.begin.filename->c_str(),                                   \
                                 loc.begin.line,                                                \
                                 ## __VA_ARGS__);                                               \
    clean;                                                                                      \
                                                                                                \
    if (target == NULL) {                                                                       \
      /* TODO(blais): This is for temporary debugging of internal errors while porting. */      \
      PyErr_PrintEx(1);                                                                         \
                                                                                                \
      build_grammar_error_from_exception(loc, builder.builder());                               \
      /* Figure out if this is stilil the right way to call for errors in the C++ parser. */    \
      YYERROR;                                                                                  \
    }                                                                                           \
  }

/* Build a grammar error from the exception context. */
void build_grammar_error_from_exception(const location& loc, PyObject* builder) {
  cerr << "build_grammar_error_from_exception " << loc << endl;
  assert(builder != nullptr);

  /* Get the exception context. */
  PyObject* ptype;
  PyObject* pvalue;
  PyObject* ptraceback;
  PyErr_Fetch(&ptype, &pvalue, &ptraceback);
  PyErr_NormalizeException(&ptype, &pvalue, &ptraceback);

  /* Clear the exception. */
  PyErr_Clear();

  if (pvalue != NULL) {
    /* Build and accumulate a new error object. {27d1d459c5cd} */
    PyObject* rv = PyObject_CallMethod(builder, "build_grammar_error", "OiOOO",
                                       loc.begin.filename, loc.begin.line,
                                       pvalue, ptype, ptraceback);
    if (rv == NULL) {
      /* Note: Leave the internal error trickling up its detail. */
      /* PyErr_SetString(PyExc_RuntimeError, */
      /*                 "Internal error: While building exception"); */
    }
  }
  else {
    PyErr_SetString(PyExc_RuntimeError,
                    "Internal error: No exception");
  }

  Py_XDECREF(ptype);
  Py_XDECREF(pvalue);
  Py_XDECREF(ptraceback);
}

// TODO(blais): Move this to error() code.
#if 0
/* Error-handling function. {ca6aab8b9748} */
void yyerror(const location& loc, yyscan_t scanner, PyObject* builder, char const* message)
{
  /* Register a syntax error with the builder. */
  PyObject* rv = PyObject_CallMethod(builder, "build_grammar_error", "Ois",
                                     loc->file_name, loc->first_line,
                                     message);
  if (rv == NULL) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Internal error: Building exception from yyerror()");
  }
  Py_XDECREF(rv);
}
#endif

#define DECREF(...) _CC_FUNC(Py_DECREF, __VA_ARGS__)

// In-memory build state for graph of nodes. This driver accepts actions from
// the parser and simply builds up the parsed state. Since the input is not
// assumed to be ordered, resolving references occurs as a separate phase.
class Builder {
public:
  Builder(scanner::Scanner& scanner, PyObject* builder_obj, PyObject* missing_obj);
  virtual ~Builder() {}

  void Initialize() {
    //// kAccountRE(StrFormat("(?:%s)(?:%s%s)+",
  }

  inline PyObject* builder() const { return builder_obj_; }
  inline PyObject* missing() const { return missing_obj_; }
  const absl::flat_hash_set<string>& active_tags() const { return active_tags_; }
  const absl::flat_hash_map<string, vector<MetaValue*>>& active_meta() const {
    return active_meta_;
  }

  // // Set the location for errors to occur.
  // // This is a stateful setter whose data get used to report errors.
  // void WithLocation(const parser::location& location) {
  //   location_ = location;
  // }

  // TODO(blais): Create an updated driver for Beancount.

  // TODO(blais): Remove this and replace it with post-parsing verification.
  string_view Account(string_view account) {
    accounts_.insert({account.data(), account.size()});
    return account;
  }

  void PushTag(string_view tag) {
    active_tags_.insert({tag.data(), tag.size()});
  }

  void PopTag(string_view tag) {
    auto iter = active_tags_.find({tag.data(), tag.size()});
    if (iter != active_tags_.end()) {
      active_tags_.erase(iter);
    } else {
      LogError(StrFormat("Attempting to pop absent tag: '%s'", tag),
               scanner_.location());
    }
  }

  // Steal the reference to `value`.
  void PushMeta(string_view key, MetaValue* value) {
    auto& value_list = active_meta_[key];
    value_list.push_back(value);
  }

  void PopMeta(string_view key) {
    auto iter = active_meta_.find(key);
    if (iter == active_meta_.end()) {
      LogError(StrFormat("Attempting to pop absent metadata key: '%s'", key),
               scanner_.location());
    } else {
      auto& value_list = iter->second;
      assert(value_list.size() > 0);
      auto* value = value_list.back();
      value_list.pop_back();
      if (value_list.empty()) {
        active_meta_.erase(iter);
      }
      delete value;
    }
  }

  void UpdatePrecisionStats(const decimal::Decimal& dec, string_view currency) {
    // TODO(blais): Update display context stats. See grammar.Builder.dcupdate().
  }

  // Common posting preparation actions.
  void PreparePosting(inter::Posting* posting,
                      const char flag,
                      string_view account,
                      bool is_total,
                      const location& loc) {
    assert(posting != nullptr);

    // Store flag and account name.
    posting->set_flag(&flag);
    posting->set_account(account.data(), account.size());

    // Store filename and line number in metadata.
    {
      auto* kv = posting->mutable_meta()->add_kv();
      kv->set_key("filename");
      assert(loc.begin.filename != nullptr);
      kv->mutable_value()->set_text(loc.begin.filename->data(), loc.begin.filename->size());
    }
    {
      auto* kv = posting->mutable_meta()->add_kv();
      kv->set_key("lineno");
      kv->mutable_value()->set_integer(loc.begin.line);
    }

    // Check conditions renamed to price annotations.
    if (posting->has_price()) {
      const auto& price = posting->price();

      // If the price is specified for the entire amount, compute the effective
      // price here and forget about that detail of the input syntax.
      if (is_total) {
        if (!posting->has_units() || !posting->units().has_number()){
          // units.number is MISSING.
          // Note: we could potentially do a better job and attempt to f
          // this up after interpolation, but this syntax is pretty rare
          // anyway.
          LogError(StrFormat("Total price on a posting without units: %s.",
                             price.DebugString()),
                   scanner_.location());
          posting->clear_price();
        } else if (price.has_number()) {
          decimal::Decimal dunits = ProtoToDecimal(posting->units().number());
          decimal::Decimal dprice;
          if (dunits.iszero()) {
            dprice = dunits;
          } else {
            dprice = ProtoToDecimal(price.number()) / dunits.abs();
          }
          DecimalToProto(dprice, posting->mutable_price()->mutable_number());
        }
      }

      // Note: Allow zero prices because we need them for round-trips for
      // conversion entries.
      //
      // if price is not None and price.number == ZERO:
      //     self.errors.append(
      //         ParserError(meta, "Price is zero: {}".format(price), None))

      // If both cost and price are specified, the currencies must match, or
      // that is an error.
      if (posting->has_cost_spec() &&
          posting->cost_spec().has_currency() &&
          price.has_currency() &&
          posting->cost_spec().currency() != price.currency()) {
        LogError(StrFormat("Cost and price currencies must match: %s != %s",
                           posting->cost_spec().currency(), price.currency()),
                 scanner_.location());
      }
    }
  }

  // Insert an error in the error log. These will be returned along with the
  // ledger as output of the parsing phase.
  void LogError(string_view message, const location& loc) {
    // TODO(blais):
  }
  void LogError(string_view message, const string_view& filename) {
    // TODO(blais):
  }
  // TODO(blais): Can we turn this error logging into a stream instead?

  // Check that all the accounts are matching the prefix names provided in the
  // options.
  void ValidateAccounts() {
  // TODO(blais):
    // if not self.account_regexp.match(account):
    //     meta = new_metadata(filename, lineno)
    //     self.errors.append(
    //         ParserError(meta, "Invalid account name: {}".format(account), None))
  }

  void Finalize() {
    // If the user left some tags unbalanced, issue an error.
    for (const auto& tag : active_tags_) {
      LogError(StrFormat("Unbalanced pushed tag: '%s'", tag),
               *scanner_.location().begin.filename);
    }

    // If the user left some metadata unpopped, issue an error.
    for (const auto& [key, value_list] : active_meta_) {
      LogError(StrFormat(
                 "Unbalanced metadata key '%s' has leftover metadata", key),
               *scanner_.location().begin.filename);
    }
  }

private:
  // Scanner (in order to get the last location).
  scanner::Scanner scanner_;

  // Python grammar builder object.
  PyObject* builder_obj_;

  // beancount.core.number.MISSING object.
  PyObject* missing_obj_ = nullptr;

  // A set of all unique account names seen in the file.
  absl::flat_hash_set<string> accounts_;

  // A set of active tags.
  absl::flat_hash_set<string> active_tags_;

  // A dict of the current active metadata fields; each of the field values is a
  // stack and the current value is at the top (last value).
  absl::flat_hash_map<string, vector<MetaValue*>> active_meta_;
};

}  // namespace parser
}  // namespace beancount
}  // %code top

// Inserted in implementation before including parser header
// (Within bison's parse() we should invoke lexer.lex(), not the global yylex().)
%code {
#undef yylex
#define yylex scanner.lex
}

//- Tokens --------------------------------------------------------------------
// Note: Token type names appear in the parser header; qualify fully.

/* Collection of value types. */
// TODO(blais): Converts this to variant below.
///// %union {
/////   char character;
/////   const char* string;
/////   PyObject* pyobj;
/////   struct {
/////       PyObject* pyobj1;
/////       PyObject* pyobj2;
/////   } pairobj;
///// }
%define api.value.type variant // See: "C++ Variants"
%define api.token.constructor
%define api.token.prefix {TOK_}

/* Special error token, redefined to carry an error message. */
%token <std::string_view> error

/* Types for terminal symbols */
%token INDENT     /* Initial indent IF at the beginning of a line */
%token DEDENT     /* Initial indent IF at the beginning of a line */
%token EOL        /* End-of-line */
%token PIPE       /* | */
%token ATAT       /* @@ */
%token AT         /* @ */
%token LCURLCURL  /* {{ */
%token RCURLCURL  /* }} */
%token LCURL      /* { */
%token RCURL      /* } */
%token COMMA      /* , */
%token TILDE      /* ~ */
%token HASH       /* # */
%token ASTERISK   /* * */
%token SLASH      /* / */
%token COLON      /* : */
%token PLUS       /* + */
%token MINUS      /* - */
%token LPAREN     /* ( */
%token RPAREN     /* ) */
%token <char> FLAG    /* Valid characters for flags */
%token TXN                 /* 'txn' keyword */
%token BALANCE             /* 'balance' keyword */
%token OPEN                /* 'open' keyword */
%token CLOSE               /* 'close' keyword */
%token COMMODITY           /* 'commodity' keyword */
%token PAD                 /* 'pad' keyword */
%token EVENT               /* 'event' keyword */
%token PRICE               /* 'price' keyword */
%token NOTE                /* 'note' keyword */
%token DOCUMENT            /* 'document' keyword */
%token QUERY               /* 'query' keyword */
%token CUSTOM              /* 'custom' keyword */
%token PUSHTAG             /* 'pushtag' keyword */
%token POPTAG              /* 'poptag' keyword */
%token PUSHMETA            /* 'pushmeta' keyword */
%token POPMETA             /* 'popmeta' keyword */
%token OPTION              /* 'option' keyword */
%token INCLUDE             /* 'include' keyword */
%token PLUGIN              /* 'plugin' keyword */
%token NONE        /* A None value (parsed as NULL) */
%token <bool> BOOL        /* A boolean, true or false */
%token <absl::CivilDay> DATE        /* A date object */
%token <std::string_view> ACCOUNT     /* The name of an account */
%token <std::string_view> CURRENCY    /* A currency specification */
%token <std::string_view> STRING      /* A quoted string, with any characters inside */
%token <decimal::Decimal> NUMBER      /* A decimal number */
%token <std::string_view> TAG         /* A tag that can be associated with a transaction */
%token <std::string_view> LINK        /* A link that can be associated with a transaction */
%token <std::string_view> KEY         /* A key in a key-value pair */

/* Types for non-terminal symbols. */
%type <char> txn
%type <char> optflag
%type <std::string_view> account

%type <PyObject*> transaction_line
%type <PyObject*> transaction

%type <std::vector<beancount::inter::Posting*>> posting_list
%type <beancount::inter::Posting*> posting_and_metadata
%type <beancount::inter::Posting*> posting

%type <PyObject*> py_indented_metadata  /* TODO(blais): Remove this. */
%type <beancount::Meta*> indented_metadata
%type <beancount::Meta*> metadata
%type <beancount::Meta::KV*> metadata_line
%type <beancount::MetaValue*> meta_value

%type <std::vector<std::string>> currency_list
%type <PyObject*> open
%type <PyObject*> close
%type <PyObject*> commodity
%type <PyObject*> balance
%type <PyObject*> pad
%type <std::pair<PyObject*, PyObject*>> amount_tolerance
%type <PyObject*> amount
%type <beancount::Amount*> incomplete_amount
%type <std::optional<decimal::Decimal>> maybe_number
%type <std::optional<std::string_view>> maybe_currency
%type <beancount::Amount*> price_annotation
%type <beancount::inter::CostSpec*> compound_amount
%type <beancount::inter::CostSpec*> cost_comp
%type <beancount::inter::CostSpec*> cost_comp_list
%type <beancount::inter::CostSpec*> cost_spec
%type <PyObject*> price
%type <PyObject*> event
%type <PyObject*> query
%type <PyObject*> note
%type <PyObject*> document
%type <PyObject*> entry
%type <PyObject*> declarations
%type <std::pair<std::string, std::string>> txn_strings  /* <payee, narration> */
%type <beancount::inter::TagsLinks*> tags_links
%type <PyObject*> filename
%type <Booking> booking
%type <decimal::Decimal> number_expr
%type <PyObject*> option
%type pushtag
%type poptag
%type pushmeta
%type popmeta
%type <PyObject*> include
%type <PyObject*> plugin
%type <PyObject*> file
%type <PyObject*> custom
%type <PyObject*> custom_value
%type <PyObject*> custom_value_list

/* Operator precedence.
 * This is pulled straight out of the textbook example:
 * https://www.gnu.org/software/bison/manual/html_node/Infix-Calc.html#Infix-Calc
 */
%left MINUS PLUS
%left ASTERISK SLASH
%precedence NEGATIVE /* negation--unary minus */

/* Start symbol. */
%start file

/* We have some number of expected shift/reduce conflicts at 'eol'. */
%expect 5



//- Grammar rules -------------------------------------------------------------
%%


/* A transaction declaration can be either 'txn' or one of the special character flags. */
txn:
  TXN
    {
      $$ = '*';
    }
  | FLAG
    {
        $$ = $1;
    }
  | ASTERISK
    {
        $$ = '*';
    }
  | HASH
    {
        $$ = '#';
    }

eol: EOL | YYEOF

/* FIXME: This needs be made more general, dealing with precedence.
   I just need this right now, so I'm putting it in, in a way that will.
   be backwards compatible, so this is just a bit of a temporary hack
   (blais, 2015-04-18). */
number_expr:
  NUMBER
  | number_expr PLUS number_expr
    {
      $$ = $1.add($3);
    }
  | number_expr MINUS number_expr
    {
      $$ = $1.sub($3);
    }
  | number_expr ASTERISK number_expr
    {
      $$ = $1.mul($3);
    }
  | number_expr SLASH number_expr
    {
      $$ = $1.div($3);
    }
  | MINUS number_expr %prec NEGATIVE
    {
      $$ = $2.minus();
    }
  | PLUS number_expr %prec NEGATIVE
    {
      $$ = $2.plus(); // Note: Not entirely sure we shouldn't just copy.
    }
  | LPAREN number_expr RPAREN
    {
      $$ = $2;
    }

txn_strings:
  STRING STRING
    {
      $$ = make_pair($1, $2);
    }
  | STRING
    {
      $$ = make_pair("", $1);
    }

tags_links:
  %empty
    {
      $$ = new inter::TagsLinks{};
    }
  | tags_links LINK
    {
      $1->add_links($2.data(), $2.size());
      $$ = $1;
    }
  | tags_links TAG
    {
      $1->add_tags($2.data(), $2.size());
      $$ = $1;
    }

/* A full matched transaction. */
transaction:
  /* A transaction with no indented body (this is valid). */
  transaction_line
    {
      $$ = $1;
    }
  /* A transaction with an indented body. */
  | transaction_line INDENT metadata posting_list DEDENT
    {
      // TODO(blais): Attach metadata and postings.
      $$ = $1;
    }

/* Matches just the first line of a transaction, without its metadata. */
transaction_line:
  DATE txn txn_strings tags_links eol
    {
      PyObject* s1 = DateToPyDate($1);
      (void)s1;

      // Encode txn_strings.
      PyObject* list = PyList_New(0);
      (void)list;
      if (!$3.first.empty()) {
        PyList_Append(list, StringToPyString(($3.first)));
      }
      if (!$3.second.empty()) {
        PyList_Append(list, StringToPyString(($3.second)));
      }

      // Split up the rest of the transaction line, tags and links.
      auto [tags, links] = TagsLinksToPython($4, &builder.active_tags());
      delete $4;
      (void)tags;
      (void)links;

#if 0
      // Create active metadata for builder.
      PyObject* active_meta = PyDict_New();
      for (const auto& [key, value_list] : builder.active_meta()) {
        assert(value_list.size() > 0);
        PyDict_SetItemString(active_meta, key.c_str(), value_list.back());
      }
#endif

      DECREF(s1, list, tags, links);
#if 0
      BUILDY(DECREF(s1, list, tags, links, active_meta),
             $$, "transaction", "ObOOOOO", s1, $2, list, tags, links, active_meta);
#endif
      Py_INCREF(Py_None);
      $$ = Py_None;
    }

optflag:
  %empty
    {
      $$ = '\0';
    }
  | ASTERISK
    {
      $$ = '*';
    }
  | HASH
    {
      $$ = '#';
    }
  | FLAG

price_annotation:
  incomplete_amount
    {
      $price_annotation = $incomplete_amount;

      // Prices may not be negative. Check and issue an error if found; fix up
      // the price to its absolute value and continue.
      if ($price_annotation->has_number()) {
        decimal::Decimal dec = ProtoToDecimal($price_annotation->number());
        if (dec.sign() == -1) {
          builder.LogError("Negative prices are not allowed "
                           "(see http://furius.ca/beancount/doc/bug-negative-prices "
                           "for workaround)", scanner.location());
          // Invert and continue.
          DecimalToProto(-dec, $price_annotation->mutable_number());
        }
      }
    }

account:
  ACCOUNT
    {
      $$ = builder.Account($1);
    }


/* A list of metadata (optionally empty), including its indentation. */
indented_metadata:
  %empty
    {
      $$ = nullptr;
    }
  | INDENT metadata DEDENT
    {
      $$ = $2;
    }

// FIXME: remove
py_indented_metadata:
  indented_metadata
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }

/* A list of metadata (optionally empty). */
metadata:
  %empty
    {
      $$ = nullptr;
    }
  | metadata metadata_line
    {
      if ($1 == nullptr) {
        $$ = new beancount::Meta();
      } else {
        $$ = $1;
      }
      auto* kv = $$->add_kv();
      kv->CopyFrom(*$2);
      delete $2;
    }

/* A single line of a metadata declaration. */
metadata_line:
  /* Regular key-value pairs. */
  KEY COLON meta_value eol
    {
      $$ = new beancount::Meta::KV();
      $$->set_key($1.data(), $1.size());
      $$->mutable_value()->CopyFrom(*$3);
      delete $3;
    }
  /* A tag can be used by itself as metadata. */
  | TAG eol
    {
      $$ = new beancount::Meta::KV();
      $$->mutable_value()->set_tag($1.data(), $1.size());
    }
  /* A link can be used by itself as metadata. */
  | LINK eol
    {
      $$ = new beancount::Meta::KV();
      $$->mutable_value()->set_link($1.data(), $1.size());
    }

/* A list of postings, possibly empty. */
posting_list:
  %empty
    {
      $$ = {};
    }
  /* Matches an empty or comment indented line. It's convenient to be able to
   * comment indented postings. */
  | posting_list eol
  /* Matches an actual posting. */
  | posting_list posting_and_metadata
    {
      $1.push_back($2);
      $$ = $1;
    }

/* A single posting and its associated metadata. */
posting_and_metadata:
  posting indented_metadata
    {
      if ($2 != nullptr) {
        $1->mutable_meta()->CopyFrom(*$2);
        delete $2;
      }
      $$ = $1;
    }

/* A posting line, without any of its metadata. */
posting:
  /* Variation with no price. */
  optflag account incomplete_amount cost_spec eol
    {
      $$ = new inter::Posting();
      $$->mutable_units()->CopyFrom(*$incomplete_amount);
      $$->mutable_cost_spec()->CopyFrom(*$cost_spec);
      builder.PreparePosting($$, $optflag, $account, false, scanner.location());
    }
  /* Variation with price. */
  | optflag account incomplete_amount cost_spec AT price_annotation eol
    {
      $$ = new inter::Posting();
      $$->mutable_units()->CopyFrom(*$incomplete_amount);
      $$->mutable_cost_spec()->CopyFrom(*$cost_spec);
      $$->mutable_price()->CopyFrom(*$price_annotation);
      builder.PreparePosting($$, $optflag, $account, false, scanner.location());
    }
  /* Variation with complete price. */
  | optflag account incomplete_amount cost_spec ATAT price_annotation eol
    {
      // TODO(blais): Merge this rule with the one above, by inspecting the
      // value of AT and ATAT.
      $$ = new inter::Posting();
      $$->mutable_units()->CopyFrom(*$incomplete_amount);
      $$->mutable_cost_spec()->CopyFrom(*$cost_spec);
      $$->mutable_price()->CopyFrom(*$price_annotation);
      builder.PreparePosting($$, $optflag, $account, true, scanner.location());
    }
  /* Variation with just an account name. */
  | optflag account eol
    {
      $$ = new inter::Posting();
      builder.PreparePosting($$, $optflag, $account, false, scanner.location());
    }

meta_value:
  STRING
    {
      $$ = new beancount::MetaValue();
      $$->set_text($1.data(), $1.size());
    }
  | account
    {
      $$ = new beancount::MetaValue();
      $$->set_account($1.data(), $1.size());
    }
  | DATE
    {
      $$ = new beancount::MetaValue();
      DateToProto($1, $$->mutable_date());
    }
  | CURRENCY
    {
      $$ = new beancount::MetaValue();
      $$->set_currency($1.data(), $1.size());
    }
  | TAG
    {
      $$ = new beancount::MetaValue();
      $$->set_tag($1.data(), $1.size());
    }
  | LINK
    {
      $$ = new beancount::MetaValue();
      $$->set_link($1.data(), $1.size());
    }
  | BOOL
    {
      $$ = new beancount::MetaValue();
      $$->set_boolean($1);
    }
  | NONE
    {
      $$ = new beancount::MetaValue();
      /* NULL is a proto not set */
    }
  | number_expr
    {
      $$ = new beancount::MetaValue();
      DecimalToProto($1, $$->mutable_number());
    }
  /* TODO(blais): Bring this back once 'amount' has been ported. */
  // | amount
  //   {
  //     $$ = new beancount::MetaValue();
  //     DecimalToProto($1, $$->mutable_number());
  //   }
  | %empty
    {
      $$ = new beancount::MetaValue();
    }

currency_list:
  %empty
    {
      $$ = {};
    }
  | CURRENCY
    {
      $$.push_back({$1.data(), $1.size()});
    }
  | currency_list COMMA CURRENCY
    {
      $$ = $1;
      $$.push_back({$3.data(), $3.size()});
    }

pushtag:
  PUSHTAG TAG eol
    {
      builder.PushTag($2);
    }

poptag:
  POPTAG TAG eol
    {
      builder.PopTag($2);
    }

pushmeta:
  PUSHMETA KEY COLON meta_value eol
    {
      builder.PushMeta($2, $4);
    }

popmeta:
  POPMETA KEY COLON eol
    {
      builder.PopMeta($2);
    }

open:
  DATE OPEN account currency_list booking eol py_indented_metadata
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);

      // Convert booking method.
      PyObject* s5;
      if ($5 != Booking::UNKNOWN) {
        s5 = StringToPyString(Booking_Name($5));
      } else {
        s5 = Py_None;
        Py_INCREF(Py_None);
      }

      // Convert currency list.
      PyObject* s4 = PyList_New(0);
      for (const auto& currency : $4) {
        PyList_Append(s4, StringToPyString(currency));
      }

      BUILDY(DECREF(s1, s3, s4, s5, $7),
               $$, "open", "OOOOO", s1, s3, s4, s5, $7);
    }

booking:
  STRING
    {
      string s1($1.data(), $1.size());
      Booking method;
      if (!Booking_Parse(s1, &method)) {
        builder.LogError(StrFormat("Invalid value for booking method: '%s'", s1),
                         scanner.location());
        // TODO(blais): For v2 behavior, set this to the global default.
        method = Booking::UNKNOWN;
      }
      $$ = method;
    }
  | %empty
    {
      $$ = Booking::UNKNOWN;
    }

close:
  DATE CLOSE account eol py_indented_metadata
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $5),
             $$, "close", "OOO", s1, s3, $5);
    }

commodity:
  DATE COMMODITY CURRENCY eol py_indented_metadata
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $5),
             $$, "commodity", "OOO", s1, s3, $5);
    }

pad:
  DATE PAD account account eol py_indented_metadata
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s3, s4, $6),
             $$, "pad", "OOOO", s1, s3, s4, $6);
    }

balance:
  DATE BALANCE account amount_tolerance eol py_indented_metadata
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $6, ($4).first, ($4).second),
             $$, "balance", "OOOOO", s1, s3, ($4).first, ($4).second, $6);
    }

amount:
  number_expr CURRENCY
    {
      PyObject* s1 = DecimalToPyDecimal($1);
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s1, s2),
             $$, "amount", "OO", s1, s2);
    }

amount_tolerance:
  number_expr CURRENCY
    {
      PyObject* s1 = DecimalToPyDecimal($1);
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s1, s2),
             ($$).first, "amount", "OO", s1, s2);
      ($$).second = Py_None;
      Py_INCREF(Py_None);
    }
  | number_expr TILDE number_expr CURRENCY
    {
      PyObject* s1 = DecimalToPyDecimal($1);
      PyObject* s3 = DecimalToPyDecimal($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s4),
             ($$).first, "amount", "OO", s1, s4);
      ($$).second = s3;
    }

maybe_number:
  number_expr
    {
      $$ = {$1};
    }
  | %empty
    {
      $$ = {};
    }

maybe_currency:
  CURRENCY
    {
      $$ = {$1};
    }
  | %empty
    {
      $$ = {};
    }

compound_amount:
  maybe_number CURRENCY
    {
      $$ = new inter::CostSpec();
      if ($1.has_value()) {
        DecimalToProto($1.value(), $$->mutable_number_per());
        builder.UpdatePrecisionStats($1.value(), $2);
      }
      $$->set_currency({$2.data(), $2.size()});
    }
  | number_expr maybe_currency
    {
      $$ = new inter::CostSpec();
      DecimalToProto($1, $$->mutable_number_per());
      if ($2.has_value()) {
        $$->set_currency({$2.value().data(), $2.value().size()});
        builder.UpdatePrecisionStats($1, $2.value());
      }
    }
  | maybe_number HASH maybe_number CURRENCY
    {
      $$ = new inter::CostSpec();
      if ($1.has_value()) {
        DecimalToProto($1.value(), $$->mutable_number_per());
        builder.UpdatePrecisionStats($1.value(), $4);
      }
      if ($3.has_value()) {
        DecimalToProto($3.value(), $$->mutable_number_total());
        builder.UpdatePrecisionStats($3.value(), $4);
      }
      $$->set_currency({$4.data(), $4.size()});
    }

incomplete_amount:
  maybe_number maybe_currency
    {
      $$ = new Amount();
      if ($1.has_value()) {
        DecimalToProto($1.value(), $$->mutable_number());
      }
      if ($2.has_value()) {
        $$->set_currency($2.value().data(), $2.value().size());
      }
    }

cost_spec:
  LCURL cost_comp_list RCURL
    {
      $$ = $2;
    }
  | LCURLCURL cost_comp_list RCURLCURL
    {
      // Note: This is using the total syntax; it is an error to set
      // `number_total` to a value in the input when using `{{...}}`.
      if ($2->has_number_total()) {
        builder.LogError(
          StrFormat("Per-unit cost may not be specified using total cost "
                    "syntax: '%s'; ignoring per-unit cost", $2->DebugString()),
          scanner.location());
      } else {
        $2->mutable_number_total()->CopyFrom($2->number_per());
      }
      $2->clear_number_per();
      $$ = $2;
    }
  | %empty
    {
      $$ = new inter::CostSpec();
    }

cost_comp_list:
  %empty
    {
      $$ = new inter::CostSpec();
    }
  | cost_comp
  | cost_comp_list COMMA cost_comp
    {
      // Note: Assuming we are allowed to return and mutate $1.
      $$ = $1;
      // TODO(blais): Check for collisions here.
      $$->MergeFrom(*$3);
      delete $3;
    }

cost_comp:
  compound_amount
  | DATE
    {
      $$ = new inter::CostSpec();
      DateToProto($1, $$->mutable_date());
    }
  | STRING
    {
      $$ = new inter::CostSpec();
      $$->set_label($1.data(), $1.size());
    }
  | ASTERISK
    {
      $$ = new inter::CostSpec();
      $$->set_merge_cost(true);
    }

price:
  DATE PRICE CURRENCY amount eol py_indented_metadata
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $4, $6),
             $$, "price", "OOOO", s1, s3, $4, $6);
    }

event:
  DATE EVENT STRING STRING eol py_indented_metadata
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s3, s4, $6),
             $$, "event", "OOOO", s1, s3, s4, $6);
    }

query:
  DATE QUERY STRING STRING eol py_indented_metadata
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s3, s4, $6),
             $$, "query", "OOOO", s1, s3, s4, $6);
    }

note:
  DATE NOTE account STRING eol py_indented_metadata
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s3, s4, $6),
             $$, "note", "OOOO", s1, s3, s4, $6);
    }

filename:
  STRING
    {
      $$ = StringToPyString($1);
    }

document:
  DATE DOCUMENT account filename tags_links eol py_indented_metadata
    {
      auto [tags, links] = TagsLinksToPython($5, &builder.active_tags());
      delete $5;
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $4, tags, links, $7),
             $$, "document", "OOOOO", s1, s3, $4, tags, links, $7);
    }

custom_value:
  STRING
    {
      PyObject* s1 = StringToPyString($1);
      BUILDY(DECREF(s1),
             $$, "custom_value", "OO", s1, Py_None);
    }
  | DATE
    {
      PyObject* s1 = DateToPyDate($1);
      BUILDY(DECREF(s1),
             $$, "custom_value", "OO", s1, Py_None);
    }
  | BOOL
    {
      PyObject* s1 = ($1) ? Py_True : Py_False;
      Py_INCREF(s1);
      BUILDY(DECREF(s1),
             $$, "custom_value", "OO", s1, Py_None);
    }
  | amount
    {
      BUILDY(DECREF($1),
             $$, "custom_value", "OO", $1, Py_None);
    }
  | number_expr
    {
      PyObject* s1 = DecimalToPyDecimal($1);
      BUILDY(DECREF(s1),
             $$, "custom_value", "OO", s1, Py_None);
    }
  | account
    {
      PyObject* s1 = StringToPyString($1);
      /* Obtain beancount.core.account.TYPE */
      PyObject* module = PyImport_ImportModule("beancount.core.account");
      PyObject* dtype = PyObject_GetAttrString(module, "TYPE");
      Py_DECREF(module);
      BUILDY(DECREF(s1, dtype),
             $$, "custom_value", "OO", s1, dtype);
    }

custom_value_list:
  %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }
  | custom_value_list custom_value
    {
      BUILDY(DECREF($1, $2),
             $$, "handle_list", "OO", $1, $2);
    }

custom:
  DATE CUSTOM STRING custom_value_list eol py_indented_metadata
   {
     PyObject* s1 = DateToPyDate($1);
     PyObject* s3 = StringToPyString($3);
     BUILDY(DECREF(s1, s3, $4, $6),
            $$, "custom", "OOOO", s1, s3, $4, $6);
   }

entry:
  transaction
  | balance
  | open
  | close
  | pad
  | document
  | note
  | event
  | price
  | commodity
  | query
  | custom

option:
  OPTION STRING STRING eol
    {
      PyObject* s2 = StringToPyString($2);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s2, s3),
             $$, "option", "OO", s2, s3);
    }

include:
  INCLUDE STRING eol
    {
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s2),
             $$, "include", "O", s2);
    }

plugin:
  PLUGIN STRING eol
    {
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s2),
             $$, "plugin", "OO", s2, Py_None);
    }
  | PLUGIN STRING STRING eol
    {
      PyObject* s2 = StringToPyString($2);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s2, s3),
             $$, "plugin", "OO", s2, s3);
    }

directive:
  pushtag
  | poptag
  | pushmeta
  | popmeta
  | option
  | include
  | plugin

declarations:
  declarations EOL
  | declarations directive
  | declarations entry
    {
      BUILDY(DECREF($1, $2),
             $$, "handle_list", "OO", $1, $2);
    }
  | declarations error
    {
      /*
       * Ignore the error and continue reducing ({3d95e55b654e}).
       * Note that with the matching rule above, "error" will
       * successfully reduce on each line that cannot reduce.
       * Non-erroneous postings after an error occurs will reduce but
       * not be included because a transaction's list of postings
       * does not include an "error" rule.
       *
       * Note: Adding EOL after the "error" rule above works to
       * reduce the number of calls to this rule resulting from the
       * appearance of an error but makes the parser errors
       * skip the next valid directive, so we just have to make sure
       * repeated runs of this rule's handling code are idempotent.
       */
      $$ = $1;
    }
  | %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }


file:
  declarations YYEOF
    {
      BUILDY(DECREF($1),
             $$, "store_result", "O", $1);
    }

// TODO(blais): What about the 'error' token?


%%
//- User code ----------------------------------------------------------------

void beancount::parser::Parser::error(const location& loc, const string& msg)
{
  // TODO(blais): Change this code to log an error and bubble that up to the
  // output. We should never write to stderr.
  using std::cerr;
  using std::endl;
  cerr << loc << ": " << msg << endl;
  if (loc.begin.line == loc.end.line && loc.begin.line == scanner.lineno()) {
    cerr << scanner.matcher().line() << endl;
    for (size_t i = 0; i < loc.begin.column; ++i)
      cerr << " ";
    for (size_t i = loc.begin.column; i <= loc.end.column; ++i)
      cerr << "~";
    cerr << endl;
  } else {
    FILE* file = scanner.in().file(); // The current file being scanned.
    if (file != NULL) {
      beancount::scanner::Scanner::Matcher* m = scanner.new_matcher(file);
      scanner.push_matcher(m);
      off_t pos = ftell(file);
      fseek(file, 0, SEEK_SET);
      for (size_t i = 1; i < loc.begin.line; ++i) {
        m->skip('\n'); // Skip to the next line.
      }
      for (size_t i = loc.begin.line; i <= loc.end.line; ++i) {
        cerr << m->line() << endl;
        m->skip('\n'); // Next line.
      }
      fseek(file, pos, SEEK_SET); // Restore position in the file to continue scanning.
      scanner.pop_matcher(); // Restore matcher.
    }
  }

  // If token is unknown (no match).
  if (scanner.size() == 0) {
    scanner.matcher().winput(); // Skip character.
  }
}

namespace beancount {

namespace parser {

Builder::Builder(scanner::Scanner& scanner, PyObject* builder_obj, PyObject* missing_obj) :
  scanner_(scanner),
  builder_obj_(builder_obj),
  missing_obj_(missing_obj)
{
  assert(builder_obj_ != nullptr);
  assert(missing_obj_ != nullptr);
}

// TODO(blais): Implement builder methods here (maybe).

}  //  namespace parser

namespace scanner {

// An extension to the generated scanner that also fetches the filename for the
// location.
class ScannerWithFile : public scanner::Scanner {
public:
  using scanner::Scanner::Scanner;

  // Set the filename for location tokens.
  void SetFilename(string_view filename) {
    filename_ = filename;
  }

  void SetLineOffset(const int line_offset) {
    line_offset_ = line_offset;
  }

  // Override the location to include the filename.
  // TODO(blais): Why do I need this again?
  beancount::parser::location location() override {
    /* yylloc.begin.line = static_cast<unsigned int>(matcher().lineno()); */
    /* yylloc.begin.column = static_cast<unsigned int>(matcher().columno()); */
    /* yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end()); */
    /* yylloc.end.column = static_cast<unsigned int>(matcher().columno_end()); */
    auto yylloc = scanner::Scanner::location();
    yylloc.begin.filename = &filename_;
    if (line_offset_ > 0) {
      yylloc.begin.line += line_offset_;
      yylloc.end.line += line_offset_;
    }
    return yylloc;
  }

  // TODO(blais): Do we still need this? At least catch the exception.
  virtual void lexer_error(const char* message) override {
    cerr << "Scanner::lexer_error: ";
    if (message) {
      cerr << *message;
    }
    cerr << endl;
    return scanner::Scanner::lexer_error(message);
  }

private:
  string filename_;
  int line_offset_ = 0;
};

}  // namespace scanner

namespace parser {

// TODO(blais): Return the parsed state.
void Parse(PyObject* builder_obj,
           const reflex::Input& input,
           const std::optional<string_view>& filename = {},
           int line_offset = 0,
           PyObject* missing_obj = nullptr) {
  // Create a scanner and builder.
  scanner::ScannerWithFile scanner(input, cout);
  if (filename.has_value()) {
    scanner.SetFilename(filename.value());
  }
  scanner.SetLineOffset(line_offset);
  parser::Builder builder(scanner, builder_obj, missing_obj);

  // Run the parser.
  beancount::parser::Parser parser(scanner, builder);
  parser.set_debug_stream(std::cerr);
  if (getenv("DEBUG")) {
    parser.set_debug_level(1);
  }
  // scanner.set_debug(1);
  try {
    int result = parser.parse();
    (void)result;
  } catch (const std::runtime_error& exc) {
    cerr << "exc " << exc.what() << endl;
  }
}

void ParseFile(PyObject* builder_obj, const string_view& filename, PyObject* missing_obj) {
  std::ifstream in = std::ifstream(string(filename), std::ios::in);
  reflex::Input input(in);
  string filename_str(filename);
  return parser::Parse(builder_obj, input, filename_str, 0, missing_obj);
}

/// std::unique_ptr<proto::Database> ParseString(const string_view& input_string,
///                                              const string_view& filename,
///                                              int line_offset) {
///   // Ensure the string is converted to UTF8 by using reflex::Input and
///   // instantiate a scanner.
///   reflex::Input input(input_string.data(), input_string.size());
///   static const string filename_str(filename);
///   return parser::Parse(input, &filename_str, line_offset);
/// }

/// std::unique_ptr<proto::Database> ParseStdin() {
///   reflex::Input input(stdin, reflex::Input::file_encoding::utf8);
///   static const string filename = "<string>";
///   auto db = parser::Parse(input, &filename);
///   fclose(stdin);
///   return db;
/// }

}  // namespace parser
}  // namespace beancount

// TODO(blais): In v3 review the syntax for uniformity:
// - Allow tags/links on all directives?
// - Remove the EMPTY_SET constraint
// - Make it possible to tag/link before the narration strings.

// TODO(blais): Remove and review all manners of locations() overriding. This
// should normally work fine out of the box, and those fixes are likely
// unnecessary.

// TODO(blais): Rework the rules to take advantage of the name aliases.

// TODO(blais): Carve a dedicated field in the protos for original location
// filename, start line, and end line, doesn't have to be generic metadata.
//
// - In the metadata, output not just the starting line but also the end line,
//   for easy extraction of the original text.

// These can get logged; override the appropriate methods.
// /home/blais/r/q/office/accounting/blais.beancount:1591.2-0x7fff5298fdf8:1591.30: syntax error, unexpected ACCOUNT, expecting DEDENT or TAG or LINK or KEY
//   Assets:CA:LondonLife:RRSP:Cash   2000 CAD
//   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
