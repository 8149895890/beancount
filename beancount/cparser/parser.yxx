/* -*- mode: c++ -*- */
// Oblique grammar for parser (Bison C++ generator).

//- Options -------------------------------------------------------------------

%require "3.7"

%language "c++"
%define api.namespace {beancount::parser}
%define api.parser.class {Parser}
%define parse.error detailed
%define parse.trace

// %verbose, have to specify the output file.
// %token-table // Has no effect on C++ code generation.

%defines
%locations
%define api.filename.type "const std::string"

// %initial-action does not work to set the filename since the location() is set
// on the symbol itself.
// This doesn't work either.
// %initial-action {
//   driver.WithLocation(@$);
// }

// Input state to parser.
%parse-param {::beancount::scanner::Scanner& lexer} {::beancount::parser::Driver& driver}

//- Code blocks ---------------------------------------------------------------

// Inserted in header, before anything else
%code requires {

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <cstdint>
#include <cstdio>
#include <fstream>
#include <list>
#include <memory>
#include <string>

#include "absl/strings/string_view.h"

namespace beancount {
namespace scanner { class Scanner; }
namespace parser { class Driver; }
typedef absl::string_view strview;

// Example of a local type; do this + below:  %type <TermList*> termlist
///   // Accumulator for term list.
///   struct TermList {
///     // List of word text.
///     std::list<std::string> words;
///
///     // List of yet-to-be-resolved (type, ident) pairs.
///     // Has ownershipo.
///     std::list<proto::Ref*> unresolved_refs;
///   };

}  // namespace beancount
}  // %code requires

// Inserted in header, at the end.
%code provides {
namespace beancount {

// TODO(blais): Implement these functions below.
/// // Parse contents from the given string.
/// // The 'line_offset' can be used in unit tests to mark the start of the test
/// // string in the parsed file.
/// std::unique_ptr<proto::Database> ParseString(const absl::string_view& input_string,
///                                             const absl::string_view& filename,
///                                             int line_offset = 0);
///
/// // Parse contents from a file.
/// std::unique_ptr<proto::Database> ParseFile(const absl::string_view& filename);
///
/// // Parse contents from stdin.
/// std::unique_ptr<proto::Database> ParseStdin();

}  // namespace beancount
}  // %code provides

//-----------------------------------------------------------------------------
// Inserted in implementation after including parser header.
%code top {

#include "beancount/cparser/scanner.h"  /* Generated by reflex. */

#include <iostream>
#include <list>
#include <string>
#include <unordered_map>
#include <utility>

#include "absl/container/flat_hash_map.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/string_view.h"
#include "reflex/input.h"

using absl::string_view;
using std::cerr;
using std::cout;
using std::endl;
using std::list;
using std::pair;
using std::string;
using std::unique_ptr;

namespace beancount {
namespace parser {

// In-memory build state for graph of nodes. This driver accepts actions from
// the parser and simply builds up the parsed state. Since the input is not
// assumed to be ordered, resolving references occurs as a separate phase.
class Driver {
public:
  Driver();
  virtual ~Driver();

  // Set the location for errors to occur.
  // This is a stateful setter whose data get used to report errors.
  void WithLocation(const parser::location& location) {
    location_ = location;
  }

  // TODO(blais): Create an updated driver for Beancount.
  //
  /// // Add a new type.
  /// proto::Type* AddType(string_view type, string_view contents,
  ///                      proto::TypeFlavor flavor);
  ///
  /// // Add a new instance of an object node.
  /// proto::Object* AddObject(string_view type,
  ///                          string_view ident,
  ///                          string_view contents);
  ///
  /// // Add a new instance of a lazy object node.
  /// // The identifer is allocated automatically.
  /// proto::Object* AddAutoObject(string_view type,
  ///                              string_view contents) {
  ///
  /// // Add a new instance of an object with default type.
  /// // The identifer is allocated automatically.
  /// proto::Object* AddDefaultObject(string_view contents) {
  ///
  /// // Get the resulting database of objects and clear it.
  /// unique_ptr<proto::Database> GetClearDatabase() {

private:

  // Last registered location.
  parser::location location_;
};

}  // namespace parser
}  // namespace beancount
}  // %code top

// Inserted in implementation before including parser header
// (Within bison's parse() we should invoke lexer.lex(), not the global yylex().)
%code {
#undef yylex
#define yylex lexer.lex
}

//- Tokens --------------------------------------------------------------------
// Note: Token type names appear in the parser header; qualify fully.

/* Collection of value types. */
// TODO(blais): Converts this to variant below.
///// %union {
/////   char character;
/////   const char* string;
/////   PyObject* pyobj;
/////   struct {
/////       PyObject* pyobj1;
/////       PyObject* pyobj2;
/////   } pairobj;
///// }
%define api.value.type variant // See: "C++ Variants"
%define api.token.constructor
%define api.token.prefix {TOK_}

/* Types for terminal symbols */
%token <absl::string_view> INDENT     /* Initial indent IF at the beginning of a line */
%token EOL        /* End-of-line */
%token PIPE       /* | */
%token ATAT       /* @@ */
%token AT         /* @ */
%token LCURLCURL  /* {{ */
%token RCURLCURL  /* }} */
%token LCURL      /* { */
%token RCURL      /* } */
%token COMMA      /* , */
%token TILDE      /* ~ */
%token HASH       /* # */
%token ASTERISK   /* * */
%token SLASH      /* / */
%token COLON      /* : */
%token PLUS       /* + */
%token MINUS      /* - */
%token LPAREN     /* ( */
%token RPAREN     /* ) */
%token <char> FLAG    /* Valid characters for flags */
%token TXN                 /* 'txn' keyword */
%token BALANCE             /* 'balance' keyword */
%token OPEN                /* 'open' keyword */
%token CLOSE               /* 'close' keyword */
%token COMMODITY           /* 'commodity' keyword */
%token PAD                 /* 'pad' keyword */
%token EVENT               /* 'event' keyword */
%token PRICE               /* 'price' keyword */
%token NOTE                /* 'note' keyword */
%token DOCUMENT            /* 'document' keyword */
%token QUERY               /* 'query' keyword */
%token CUSTOM              /* 'custom' keyword */
%token PUSHTAG             /* 'pushtag' keyword */
%token POPTAG              /* 'poptag' keyword */
%token PUSHMETA            /* 'pushmeta' keyword */
%token POPMETA             /* 'popmeta' keyword */
%token OPTION              /* 'option' keyword */
%token INCLUDE             /* 'include' keyword */
%token PLUGIN              /* 'plugin' keyword */
%token <PyObject*> NONE        /* A None value (parsed as NULL) */
%token <PyObject*> BOOL        /* A boolean, true or false */
%token <PyObject*> DATE        /* A date object */
%token <PyObject*> ACCOUNT     /* The name of an account */
%token <PyObject*> CURRENCY    /* A currency specification */
%token <PyObject*> STRING      /* A quoted string, with any characters inside */
%token <PyObject*> NUMBER      /* A floating-point number */
%token <PyObject*> TAG         /* A tag that can be associated with a transaction */
%token <PyObject*> LINK        /* A link that can be associated with a transaction */
%token <PyObject*> KEY         /* A key in a key-value pair */

/// /* Types for non-terminal symbols. */
/// %type <character> txn
/// %type <character> optflag
/// %type <pyobj> account
/// %type <pyobj> transaction
/// %type <pyobj> posting
/// %type <pyobj> key_value
/// %type <pyobj> key_value_line
/// %type <pyobj> key_value_list
/// %type <pyobj> key_value_value
/// %type <pyobj> posting_or_kv_list
/// %type <pyobj> currency_list
/// %type <pyobj> open
/// %type <pyobj> close
/// %type <pyobj> commodity
/// %type <pyobj> balance
/// %type <pyobj> pad
/// %type <pairobj> amount_tolerance
/// %type <pyobj> amount
/// %type <pyobj> incomplete_amount
/// %type <pyobj> compound_amount
/// %type <pyobj> maybe_number
/// %type <pyobj> maybe_currency
/// %type <pyobj> price_annotation
/// %type <pyobj> cost_comp
/// %type <pyobj> cost_comp_list
/// %type <pyobj> cost_spec
/// %type <pyobj> price
/// %type <pyobj> event
/// %type <pyobj> query
/// %type <pyobj> note
/// %type <pyobj> document
/// %type <pyobj> entry
/// %type <pyobj> declarations
/// %type <pyobj> txn_strings
/// %type <pyobj> tags_links
/// %type <pyobj> filename
/// %type <pyobj> opt_booking
/// %type <pyobj> number_expr
/// %type <pyobj> option
/// %type <pyobj> pushtag
/// %type <pyobj> poptag
/// %type <pyobj> pushmeta
/// %type <pyobj> popmeta
/// %type <pyobj> include
/// %type <pyobj> plugin
/// %type <pyobj> file
/// %type <pyobj> custom
/// %type <pyobj> custom_value
/// %type <pyobj> custom_value_list

/* Operator precedence.
 * This is pulled straight out of the textbook example:
 * https://www.gnu.org/software/bison/manual/html_node/Infix-Calc.html#Infix-Calc
 */
%left MINUS PLUS
%left ASTERISK SLASH
%precedence NEGATIVE /* negation--unary minus */

/* Start symbol. */
%start file

/* We have some number of expected shift/reduce conflicts at 'eol'. */
%expect 0



//- Grammar rules -------------------------------------------------------------
%%

// TODO(blais): remove
file:
  empty
  | error
    {
      yyerrok;
    }

empty:

%%
//- User code ----------------------------------------------------------------

void beancount::parser::Parser::error(const location& loc, const string& msg)
{
  // TODO(blais): Change this code to log an error and bubble that up to the
  // output. We should never write to stderr.
  using std::cerr;
  using std::endl;
  cerr << loc << ": " << msg << endl;
  if (loc.begin.line == loc.end.line && loc.begin.line == lexer.lineno()) {
    cerr << lexer.matcher().line() << endl;
    for (size_t i = 0; i < loc.begin.column; ++i)
      cerr << " ";
    for (size_t i = loc.begin.column; i <= loc.end.column; ++i)
      cerr << "~";
    cerr << endl;
  } else {
    FILE* file = lexer.in().file(); // The current file being scanned.
    if (file != NULL) {
      beancount::scanner::Scanner::Matcher* m = lexer.new_matcher(file);
      lexer.push_matcher(m);
      off_t pos = ftell(file);
      fseek(file, 0, SEEK_SET);
      for (size_t i = 1; i < loc.begin.line; ++i) {
        m->skip('\n'); // Skip to the next line.
      }
      for (size_t i = loc.begin.line; i <= loc.end.line; ++i) {
        cerr << m->line() << endl;
        m->skip('\n'); // Next line.
      }
      fseek(file, pos, SEEK_SET); // Restore position in the file to continue scanning.
      lexer.pop_matcher(); // Restore matcher.
    }
  }

  // If token is unknown (no match).
  if (lexer.size() == 0) {
    lexer.matcher().winput(); // Skip character.
  }
}

namespace beancount {

namespace parser {

Driver::Driver() {
}

Driver::~Driver() {
}

// TODO(blais): Implement driver methods here (maybe).

}  //  namespace parser

namespace scanner {

// An extension to the generated scanner that also fetches the filename for the
// location.
class ScannerWithFile : public scanner::Scanner {
public:
  using scanner::Scanner::Scanner;

  // Set the filename for location tokens.
  void SetFilename(const string* filename) {
    filename_ = filename;
  }

  void SetLineOffset(const int line_offset) {
    line_offset_ = line_offset;
  }

  // Override the location to include the filename.
  beancount::parser::location location() override
  {
    /* yylloc.begin.line = static_cast<unsigned int>(matcher().lineno()); */
    /* yylloc.begin.column = static_cast<unsigned int>(matcher().columno()); */
    /* yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end()); */
    /* yylloc.end.column = static_cast<unsigned int>(matcher().columno_end()); */
    auto yylloc = scanner::Scanner::location();
    if (filename_) {
      yylloc.begin.filename = filename_;
    }
    if (line_offset_ > 0) {
      yylloc.begin.line += line_offset_;
      yylloc.end.line += line_offset_;
    }
    return yylloc;
  }
private:
  const string* filename_ = nullptr;
  int line_offset_ = 0;
};

}  // namespace scanner

namespace parser {

// TODO(blais): Implement parser here.
/// // Parse the given input to a database.
/// std::unique_ptr<proto::Database> Parse(const reflex::Input& input,
///                                        const string* filename = nullptr,
///                                        int line_offset = 0) {
///   // Create a scanner and driver.
///   scanner::ScannerWithFile scanner(input, cout);
///   if (filename != nullptr) {
///     scanner.SetFilename(filename);
///   }
///   scanner.SetLineOffset(line_offset);
///   parser::Driver driver;
///
///   // Run the parser.
///   beancount::parser::Parser parser(scanner, driver);
///   int result = parser.parse();
///   (void)result;
///
///   auto db = driver.GetClearDatabase();
///   return db;
/// }
///
/// }  // namespace parser
///
/// std::unique_ptr<proto::Database> ParseString(const string_view& input_string,
///                                              const string_view& filename,
///                                              int line_offset) {
///   // Ensure the string is converted to UTF8 by using reflex::Input and
///   // instantiate a scanner.
///   reflex::Input input(input_string.data(), input_string.size());
///   static const string filename_str(filename);
///   return parser::Parse(input, &filename_str, line_offset);
/// }
///
/// std::unique_ptr<proto::Database> ParseFile(const string_view& filename) {
///   std::ifstream in = std::ifstream(string(filename), std::ios::in);
///   reflex::Input input(in);
///   string filename_str(filename);
///   return parser::Parse(input, &filename_str);
/// }
///
/// std::unique_ptr<proto::Database> ParseStdin() {
///   reflex::Input input(stdin, reflex::Input::file_encoding::utf8);
///   static const string filename = "<string>";
///   auto db = parser::Parse(input, &filename);
///   fclose(stdin);
///   return db;
/// }

}  // namespace parser

}  // namespace beancount
