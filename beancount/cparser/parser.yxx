/* -*- mode: c++ -*- */
// Parser grammar for beancount 3.0 input syntax (Bison C++).

//- Options -------------------------------------------------------------------

%require "3.7"

%language "c++"
%define api.namespace {beancount::parser}
%define api.parser.class {Parser}
%define parse.error detailed
%define parse.trace

// %verbose, have to specify the output file.
// %token-table // Has no effect on C++ code generation.

%defines
%locations
%define api.filename.type "const std::string"

// %initial-action does not work to set the filename since the location() is set
// on the symbol itself.
// This doesn't work either.
// %initial-action {
//   driver.WithLocation(@$);
// }

// Input state to parser.
%parse-param {::beancount::scanner::Scanner& scanner} {::beancount::parser::Builder& builder}

//- Code blocks ---------------------------------------------------------------

// Inserted in header, before anything else
%code requires {

#include "beancount/cparser/parser.pb.h"
#include "beancount/ccore/data.pb.h"

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <cstdint>
#include <cstdio>
#include <fstream>
#include <list>
#include <memory>
#include <string>
#include <optional>

#include "absl/strings/string_view.h"
#include "absl/time/civil_time.h"

#include "decimal.hh"

namespace beancount {
namespace scanner { class Scanner; }
namespace parser { class Builder; }

// Example of a local type; do this + below:  %type <TermList*> termlist
///   // Accumulator for term list.
///   struct TermList {
///     // List of word text.
///     std::list<std::string> words;
///
///     // List of yet-to-be-resolved (type, ident) pairs.
///     // Has ownershipo.
///     std::list<proto::Ref*> unresolved_refs;
///   };

}  // namespace beancount
}  // %code requires

// Inserted in header, at the end.
%code provides {
namespace beancount {

// TODO(blais): Implement these functions below.
/// // Parse contents from the given string.
/// // The 'line_offset' can be used in unit tests to mark the start of the test
/// // string in the parsed file.
/// std::unique_ptr<proto::Database> ParseString(const string_view& input_string,
///                                             const string_view& filename,
///                                             int line_offset = 0);
///
/// // Parse contents from a file.
/// std::unique_ptr<proto::Database> ParseFile(const string_view& filename);
///
/// // Parse contents from stdin.
/// std::unique_ptr<proto::Database> ParseStdin();

}  // namespace beancount
}  // %code provides

//-----------------------------------------------------------------------------
// Inserted in implementation after including parser header.
%code top {

#include "beancount/cparser/scanner.h"  /* Generated by reflex. */
#include "beancount/parser/macros.h"
#include "beancount/parser/tokens.h"

#include <iostream>
#include <list>
#include <string>
#include <unordered_map>
#include <utility>

#include "absl/container/flat_hash_map.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/string_view.h"
#include "reflex/input.h"

using std::string_view;
using std::cerr;
using std::cout;
using std::endl;
using std::list;
using std::pair;
using std::string;
using std::unique_ptr;

namespace beancount {
namespace parser {

// Default and only encoding we really have to bother supporting.
// TODO(blais): Revise this later, maybe make it part of the state of the builder.
static const char* kEncoding = "UTF-8";

// Convert string_view to Python string object.
inline PyObject* StringToPyString(const string_view s) {
  return PyUnicode_Decode(s.data(), s.size(), kEncoding, "ignore");
}

// Convert absl::CivilDay to Python date object.
inline PyObject* DateToPyDate(const absl::CivilDay& d) {
  return pydate_from_civil_day(d.year(), d.month(), d.day());
}

// Convert a decimal::Decimal to a PyDecimal.
inline PyObject* DecimalToPyDecimal(const decimal::Decimal& d) {
  return pydecimal_from_cstring(d.to_sci().c_str());
}

// Create two sets from a TagsLinks object.
std::tuple<PyObject*, PyObject*> TagsLinksToPython(TagsLinks* tags_links) {
  assert(tags_links != nullptr);
  PyObject* tags = PySet_New(0);
  for (const auto& tag : tags_links->tags()) {
    PySet_Add(tags, StringToPyString(tag));
  }
  PyObject* links = PySet_New(0);
  for (const auto& link : tags_links->links()) {
    PySet_Add(links, StringToPyString(link));
  }
  return {tags, links};
}

/*
 * Call a builder method and detect and handle a Python exception being raised
 * in the handler. Always run the code to clean the references provided by the
 * reduced rule. {05bb0fb60e86}
 */
#define BUILDY(clean, target, method_name, format, ...)                 \
  target = PyObject_CallMethod(builder.obj(), method_name, "Oi" format, \
                               location().begin.filename,               \
                               location().begin.line,                   \
                               ## __VA_ARGS__);                         \
  clean;                                                                \
  if (target == NULL) {                                                 \
    build_grammar_error_from_exception(location(), builder.obj());      \
    YYERROR;                                                            \
  }

#define MISSING_OBJ builder.missing()

/* Build a grammar error from the exception context. */
void build_grammar_error_from_exception(const location& loc, PyObject* builder)
{
#if 0
  /* Get the exception context. */
  PyObject* ptype;
  PyObject* pvalue;
  PyObject* ptraceback;
  PyErr_Fetch(&ptype, &pvalue, &ptraceback);
  PyErr_NormalizeException(&ptype, &pvalue, &ptraceback);

  /* Clear the exception. */
  PyErr_Clear();

  if (pvalue != NULL) {
      /* Build and accumulate a new error object. {27d1d459c5cd} */
      PyObject* rv = PyObject_CallMethod(builder, "build_grammar_error", "OiOOO",
                                         loc->file_name, loc->first_line,
                                         pvalue, ptype, ptraceback);
      if (rv == NULL) {
          /* Note: Leave the internal error trickling up its detail. */
          /* PyErr_SetString(PyExc_RuntimeError, */
          /*                 "Internal error: While building exception"); */
      }
  }
  else {
      PyErr_SetString(PyExc_RuntimeError,
                      "Internal error: No exception");
  }

  Py_XDECREF(ptype);
  Py_XDECREF(pvalue);
  Py_XDECREF(ptraceback);
#endif
}

// TODO(blais): Move this to error() code.
#if 0
/* Error-handling function. {ca6aab8b9748} */
void yyerror(const location& loc, yyscan_t scanner, PyObject* builder, char const* message)
{
  /* Register a syntax error with the builder. */
  PyObject* rv = PyObject_CallMethod(builder, "build_grammar_error", "Ois",
                                     loc->file_name, loc->first_line,
                                     message);
  if (rv == NULL) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Internal error: Building exception from yyerror()");
  }
  Py_XDECREF(rv);
}
#endif

#define DECREF(...) _CC_FUNC(Py_DECREF, __VA_ARGS__)







// In-memory build state for graph of nodes. This driver accepts actions from
// the parser and simply builds up the parsed state. Since the input is not
// assumed to be ordered, resolving references occurs as a separate phase.
class Builder {
public:
  Builder(PyObject* missing);
  virtual ~Builder();

  inline PyObject* obj() const { return builder_obj_; }
  inline PyObject* missing() const { return missing_; }

  // Set the location for errors to occur.
  // This is a stateful setter whose data get used to report errors.
  void WithLocation(const parser::location& location) {
    location_ = location;
  }

  // TODO(blais): Create an updated driver for Beancount.


  string_view Account(const location& loc, string_view account) {
    // if not self.account_regexp.match(account):
    //     meta = new_metadata(filename, lineno)
    //     self.errors.append(
    //         ParserError(meta, "Invalid account name: {}".format(account), None))
    // # Intern account names. This should reduces memory usage a
    // # fair bit because these strings are repeated liberally.
    // return self.accounts.setdefault(account, account)

    // BUILDY(DECREF($1),
    //        $$, "account", "O", $1);
    return account;
  }





private:
  // beancount.core.number.MISSING object.
  PyObject* missing_ = nullptr;

  // Last registered location.
  parser::location location_;

  PyObject* builder_obj_;
};

}  // namespace parser
}  // namespace beancount
}  // %code top

// Inserted in implementation before including parser header
// (Within bison's parse() we should invoke lexer.lex(), not the global yylex().)
%code {
#undef yylex
#define yylex scanner.lex
}

//- Tokens --------------------------------------------------------------------
// Note: Token type names appear in the parser header; qualify fully.

/* Collection of value types. */
// TODO(blais): Converts this to variant below.
///// %union {
/////   char character;
/////   const char* string;
/////   PyObject* pyobj;
/////   struct {
/////       PyObject* pyobj1;
/////       PyObject* pyobj2;
/////   } pairobj;
///// }
%define api.value.type variant // See: "C++ Variants"
%define api.token.constructor
%define api.token.prefix {TOK_}

/* Special error token, redefined to carry an error message. */
%token <std::string_view> error

/* Types for terminal symbols */
%token <std::string_view> INDENT     /* Initial indent IF at the beginning of a line */
%token EOL        /* End-of-line */
%token PIPE       /* | */
%token ATAT       /* @@ */
%token AT         /* @ */
%token LCURLCURL  /* {{ */
%token RCURLCURL  /* }} */
%token LCURL      /* { */
%token RCURL      /* } */
%token COMMA      /* , */
%token TILDE      /* ~ */
%token HASH       /* # */
%token ASTERISK   /* * */
%token SLASH      /* / */
%token COLON      /* : */
%token PLUS       /* + */
%token MINUS      /* - */
%token LPAREN     /* ( */
%token RPAREN     /* ) */
%token <char> FLAG    /* Valid characters for flags */
%token TXN                 /* 'txn' keyword */
%token BALANCE             /* 'balance' keyword */
%token OPEN                /* 'open' keyword */
%token CLOSE               /* 'close' keyword */
%token COMMODITY           /* 'commodity' keyword */
%token PAD                 /* 'pad' keyword */
%token EVENT               /* 'event' keyword */
%token PRICE               /* 'price' keyword */
%token NOTE                /* 'note' keyword */
%token DOCUMENT            /* 'document' keyword */
%token QUERY               /* 'query' keyword */
%token CUSTOM              /* 'custom' keyword */
%token PUSHTAG             /* 'pushtag' keyword */
%token POPTAG              /* 'poptag' keyword */
%token PUSHMETA            /* 'pushmeta' keyword */
%token POPMETA             /* 'popmeta' keyword */
%token OPTION              /* 'option' keyword */
%token INCLUDE             /* 'include' keyword */
%token PLUGIN              /* 'plugin' keyword */
%token NONE        /* A None value (parsed as NULL) */
%token <bool> BOOL        /* A boolean, true or false */
%token <absl::CivilDay> DATE        /* A date object */
%token <std::string_view> ACCOUNT     /* The name of an account */
%token <std::string_view> CURRENCY    /* A currency specification */
%token <std::string_view> STRING      /* A quoted string, with any characters inside */
%token <decimal::Decimal> NUMBER      /* A decimal number */
%token <std::string_view> TAG         /* A tag that can be associated with a transaction */
%token <std::string_view> LINK        /* A link that can be associated with a transaction */
%token <std::string_view> KEY         /* A key in a key-value pair */

/* Types for non-terminal symbols. */
%type <char> txn
%type <char> optflag
%type <std::string_view> account
%type <PyObject*> transaction
%type <PyObject*> posting
%type <PyObject*> key_value
%type <PyObject*> key_value_line
%type <PyObject*> key_value_list
%type <PyObject*> key_value_value
%type <PyObject*> posting_or_kv_list
%type <PyObject*> currency_list
%type <PyObject*> open
%type <PyObject*> close
%type <PyObject*> commodity
%type <PyObject*> balance
%type <PyObject*> pad
%type <std::pair<PyObject*, PyObject*>> amount_tolerance
%type <PyObject*> amount
%type <PyObject*> incomplete_amount
%type <PyObject*> compound_amount
%type <std::optional<decimal::Decimal>> c_maybe_number
%type <PyObject*> maybe_number
%type <std::optional<std::string_view>> c_maybe_currency
%type <PyObject*> maybe_currency
%type <PyObject*> price_annotation
%type <PyObject*> cost_comp
%type <PyObject*> cost_comp_list
%type <PyObject*> cost_spec
%type <PyObject*> price
%type <PyObject*> event
%type <PyObject*> query
%type <PyObject*> note
%type <PyObject*> document
%type <PyObject*> entry
%type <PyObject*> declarations
%type <std::pair<std::string, std::string>> txn_strings  /* <payee, narration> */
%type <beancount::TagsLinks*> tags_links
%type <PyObject*> filename
%type <PyObject*> opt_booking
%type <decimal::Decimal> number_expr
%type <PyObject*> option
%type <PyObject*> pushtag
%type <PyObject*> poptag
%type <PyObject*> pushmeta
%type <PyObject*> popmeta
%type <PyObject*> include
%type <PyObject*> plugin
%type <PyObject*> file
%type <PyObject*> custom
%type <PyObject*> custom_value
%type <PyObject*> custom_value_list

/* Operator precedence.
 * This is pulled straight out of the textbook example:
 * https://www.gnu.org/software/bison/manual/html_node/Infix-Calc.html#Infix-Calc
 */
%left MINUS PLUS
%left ASTERISK SLASH
%precedence NEGATIVE /* negation--unary minus */

/* Start symbol. */
%start file

/* We have some number of expected shift/reduce conflicts at 'eol'. */
%expect 7



//- Grammar rules -------------------------------------------------------------
%%


/* A transaction declaration can be either 'txn' or one of the special character flags. */
txn:
  TXN
    {
      $$ = '*';
    }
  | FLAG
    {
        $$ = $1;
    }
  | ASTERISK
    {
        $$ = '*';
    }
  | HASH
    {
        $$ = '#';
    }

eol: EOL | YYEOF

/* FIXME: This needs be made more general, dealing with precedence.
   I just need this right now, so I'm putting it in, in a way that will.
   be backwards compatible, so this is just a bit of a temporary hack
   (blais, 2015-04-18). */
number_expr:
  NUMBER
  | number_expr PLUS number_expr
    {
      $$ = $1.add($3);
    }
  | number_expr MINUS number_expr
    {
      $$ = $1.sub($3);
    }
  | number_expr ASTERISK number_expr
    {
      $$ = $1.mul($3);
    }
  | number_expr SLASH number_expr
    {
      $$ = $1.div($3);
    }
  | MINUS number_expr %prec NEGATIVE
    {
      $$ = $2.minus();
    }
  | PLUS number_expr %prec NEGATIVE
    {
      $$ = $2.plus(); // Note: Not entirely sure we shouldn't just copy.
    }
  | LPAREN number_expr RPAREN
    {
      $$ = $2;
    }

txn_strings:
  STRING STRING
    {
      $$ = make_pair($1, $2);
    }
  | STRING
    {
      $$ = make_pair("", $1);
    }

tags_links:
  %empty
    {
      $$ = new TagsLinks{};
    }
  | tags_links LINK
    {
      $1->add_links($2.data(), $2.size());
      $$ = $1;
    }
  | tags_links TAG
    {
      $1->add_tags($2.data(), $2.size());
      $$ = $1;
    }

transaction:
  DATE txn txn_strings tags_links eol posting_or_kv_list
    {
      auto [tags, links] = TagsLinksToPython($4);
      delete $4;
      PyObject* s1 = DateToPyDate($1);
      PyObject* list = PyList_New(0);
      if (!$3.first.empty()) {
        PyList_Append(list, StringToPyString(($3.first)));
      }
      if (!$3.second.empty()) {
        PyList_Append(list, StringToPyString(($3.second)));
      }
      BUILDY(DECREF(s1, list, tags, links, $6),
             $$, "transaction", "ObOOO", s1, $2, list, tags, links, $6);
    }

optflag:
  %empty
    {
      $$ = '\0';
    }
  | ASTERISK
    {
      $$ = '*';
    }
  | HASH
    {
      $$ = '#';
    }
  | FLAG

price_annotation:
  incomplete_amount

// TODO(blais): Bubble up string_view through to callers.
account:
  ACCOUNT
    {
      $$ = builder.Account(location(), $1);
    }

posting:
  INDENT optflag account incomplete_amount cost_spec eol
    {
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s3, $4, $5),
             $$, "posting", "OOOOOb", s3, $4, $5, Py_None, Py_False, $2);
    }
  | INDENT optflag account incomplete_amount cost_spec AT price_annotation eol
    {
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s3, $4, $5, $7),
             $$, "posting", "OOOOOb", s3, $4, $5, $7, Py_False, $2);
    }
  | INDENT optflag account incomplete_amount cost_spec ATAT price_annotation eol
    {
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s3, $4, $5, $7),
             $$, "posting", "OOOOOb", s3, $4, $5, $7, Py_True, $2);
    }
  | INDENT optflag account eol
    {
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s3),
             $$, "posting", "OOOOOb", s3, MISSING_OBJ, Py_None, Py_None, Py_False, $2);
    }

key_value:
  KEY COLON key_value_value
    {
      PyObject* s1 = StringToPyString($1);
      BUILDY(DECREF(s1, $3),
             $$, "key_value", "OO", s1, $3);
    }

key_value_line:
  INDENT key_value eol
    {
      $$ = $2;
    }

key_value_value:
  STRING
    {
      $$ = StringToPyString($1);
    }
  | account
    {
      $$ = StringToPyString($1);
    }
  | DATE
    {
      $$ = DateToPyDate($1);
    }
  | CURRENCY
    {
      $$ = StringToPyString($1);
    }
  | TAG
    {
      $$ = StringToPyString($1);
    }
  | BOOL
    {
      PyObject* value = ($1) ? Py_True : Py_False;
      Py_INCREF(value);
      $$ = value;
    }

  | NONE
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }
  | number_expr
    {
      $$ = DecimalToPyDecimal($1);
    }

  | amount
  | %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }

posting_or_kv_list:
  %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }
  | posting_or_kv_list INDENT eol
    {
      $$ = $1;
    }
  | posting_or_kv_list INDENT tags_links eol
    {
      auto [tags, links] = TagsLinksToPython($3);
      delete $3;
      PyObject* tags_links;
      BUILDY(DECREF(tags, links),
             tags_links, "tags_links_new", "OO", tags, links);
      BUILDY(DECREF($1, tags_links),
             $$, "handle_list", "OO", $1, tags_links);
    }
  | posting_or_kv_list key_value_line
    {
      BUILDY(DECREF($1, $2),
             $$, "handle_list", "OO", $1, $2);
    }
  | posting_or_kv_list posting
    {
      BUILDY(DECREF($1, $2),
             $$, "handle_list", "OO", $1, $2);
    }

key_value_list:
  %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }
  | key_value_list INDENT eol
    {
      $$ = $1;
    }
  | key_value_list key_value_line
    {
      BUILDY(DECREF($1, $2),
             $$, "handle_list", "OO", $1, $2);
    }

currency_list:
  %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }
  | CURRENCY
    {
      PyObject* s1 = StringToPyString($1);
      BUILDY(DECREF(s1),
             $$, "handle_list", "OO", Py_None, s1);
    }
  | currency_list COMMA CURRENCY
    {
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF($1, s3),
             $$, "handle_list", "OO", $1, s3);
    }

pushtag:
  PUSHTAG TAG eol
    {
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s2),
             $$, "pushtag", "O", s2);
    }

poptag:
  POPTAG TAG eol
    {
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s2),
             $$, "poptag", "O", s2);
    }

pushmeta:
  PUSHMETA key_value eol
    {
      /* Note: key_value is a tuple, Py_BuildValue() won't wrap it up
       * within a tuple, so expand in the method (it receives two
       * objects). See https://docs.python.org/3.4/c-api/arg.html. */
      BUILDY(DECREF($2),
             $$, "pushmeta", "O", $2);
    }

popmeta:
  POPMETA KEY COLON eol
    {
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s2),
             $$, "popmeta", "O", s2);
    }

open:
  DATE OPEN account currency_list opt_booking eol key_value_list
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $4, $5, $7),
               $$, "open", "OOOOO", s1, s3, $4, $5, $7);
    }

opt_booking:
  STRING
    {
      $$ = StringToPyString($1);
    }
  | %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }

close:
  DATE CLOSE account eol key_value_list
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $5),
             $$, "close", "OOO", s1, s3, $5);
    }

commodity:
  DATE COMMODITY CURRENCY eol key_value_list
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $5),
             $$, "commodity", "OOO", s1, s3, $5);
    }

pad:
  DATE PAD account account eol key_value_list
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s3, s4, $6),
             $$, "pad", "OOOO", s1, s3, s4, $6);
    }

balance:
  DATE BALANCE account amount_tolerance eol key_value_list
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $6, ($4).first, ($4).second),
             $$, "balance", "OOOOO", s1, s3, ($4).first, ($4).second, $6);
    }

amount:
  number_expr CURRENCY
    {
      PyObject* s1 = DecimalToPyDecimal($1);
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s1, s2),
             $$, "amount", "OO", s1, s2);
    }

amount_tolerance:
  number_expr CURRENCY
    {
      PyObject* s1 = DecimalToPyDecimal($1);
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s1, s2),
             ($$).first, "amount", "OO", s1, s2);
      ($$).second = Py_None;
      Py_INCREF(Py_None);
    }
  | number_expr TILDE number_expr CURRENCY
    {
      PyObject* s1 = DecimalToPyDecimal($1);
      PyObject* s3 = DecimalToPyDecimal($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s4),
             ($$).first, "amount", "OO", s1, s4);
      ($$).second = s3;
    }

c_maybe_number:
  number_expr
    {
      $$ = {$1};
    }
  | %empty
    {
      $$ = {};
    }

c_maybe_currency:
  CURRENCY
    {
      $$ = {$1};
    }
  | %empty
    {
      $$ = {};
    }

// TODO(blais): This is temporary, fold through to children below.
maybe_number:
  c_maybe_number
    {
      if ($1.has_value()) {
        $$ = DecimalToPyDecimal($1.value());
      } else {
        Py_INCREF(MISSING_OBJ);
        $$ = MISSING_OBJ;
      }
    }

// TODO(blais): This is temporary, fold through to children below.
maybe_currency:
  c_maybe_currency
    {
      if ($1.has_value()) {
        $$ = StringToPyString($1.value());
      } else {
        Py_INCREF(MISSING_OBJ);
        $$ = MISSING_OBJ;
      }
    }

compound_amount:
  maybe_number CURRENCY
    {
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF($1, s2),
             $$, "compound_amount", "OOO", $1, Py_None, s2);
    }
  | number_expr maybe_currency
    {
      PyObject* s1 = DecimalToPyDecimal($1);
      BUILDY(DECREF(s1, $2),
             $$, "compound_amount", "OOO", s1, Py_None, $2);
    }
  | maybe_number HASH maybe_number CURRENCY
    {
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF($1, $3, s4),
             $$, "compound_amount", "OOO", $1, $3, s4);
    }

incomplete_amount:
  maybe_number maybe_currency
    {
      BUILDY(DECREF($1, $2),
             $$, "amount", "OO", $1, $2);
    }

cost_spec:
  LCURL cost_comp_list RCURL
    {
      BUILDY(DECREF($2),
             $$, "cost_spec", "OO", $2, Py_False);
    }
  | LCURLCURL cost_comp_list RCURLCURL
    {
      BUILDY(DECREF($2),
             $$, "cost_spec", "OO", $2, Py_True);
    }
  | %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }

cost_comp_list:
  %empty
    {
      /* We indicate that there was a cost if there */
      $$ = PyList_New(0);
    }
  | cost_comp
    {
      BUILDY(DECREF($1),
             $$, "handle_list", "OO", Py_None, $1);
    }
  | cost_comp_list COMMA cost_comp
    {
      BUILDY(DECREF($1, $3),
             $$, "handle_list", "OO", $1, $3);
    }

cost_comp:
  compound_amount
  | DATE
    {
      $$ = DateToPyDate($1);
    }
  | STRING
    {
      $$ = StringToPyString($1);
    }
  | ASTERISK
    {
      BUILDY(,
             $$, "cost_merge", "O", Py_None);
    }

price:
  DATE PRICE CURRENCY amount eol key_value_list
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $4, $6),
             $$, "price", "OOOO", s1, s3, $4, $6);
    }

event:
  DATE EVENT STRING STRING eol key_value_list
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s3, s4, $6),
             $$, "event", "OOOO", s1, s3, s4, $6);
    }

query:
  DATE QUERY STRING STRING eol key_value_list
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s3, s4, $6),
             $$, "query", "OOOO", s1, s3, s4, $6);
    }

note:
  DATE NOTE account STRING eol key_value_list
    {
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      PyObject* s4 = StringToPyString($4);
      BUILDY(DECREF(s1, s3, s4, $6),
             $$, "note", "OOOO", s1, s3, s4, $6);
    }

filename:
  STRING
    {
      $$ = StringToPyString($1);
    }

document:
  DATE DOCUMENT account filename tags_links eol key_value_list
    {
      auto [tags, links] = TagsLinksToPython($5);
      delete $5;
      PyObject* s1 = DateToPyDate($1);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s1, s3, $4, tags, links, $7),
             $$, "document", "OOOOO", s1, s3, $4, tags, links, $7);
    }

custom_value:
  STRING
    {
      PyObject* s1 = StringToPyString($1);
      BUILDY(DECREF(s1),
             $$, "custom_value", "OO", s1, Py_None);
    }
  | DATE
    {
      PyObject* s1 = DateToPyDate($1);
      BUILDY(DECREF(s1),
             $$, "custom_value", "OO", s1, Py_None);
    }
  | BOOL
    {
      PyObject* s1 = ($1) ? Py_True : Py_False;
      Py_INCREF(s1);
      BUILDY(DECREF(s1),
             $$, "custom_value", "OO", s1, Py_None);
    }
  | amount
    {
      BUILDY(DECREF($1),
             $$, "custom_value", "OO", $1, Py_None);
    }
  | number_expr
    {
      PyObject* s1 = DecimalToPyDecimal($1);
      BUILDY(DECREF(s1),
             $$, "custom_value", "OO", s1, Py_None);
    }
  | account
    {
      PyObject* s1 = StringToPyString($1);
      /* Obtain beancount.core.account.TYPE */
      PyObject* module = PyImport_ImportModule("beancount.core.account");
      PyObject* dtype = PyObject_GetAttrString(module, "TYPE");
      Py_DECREF(module);
      BUILDY(DECREF(s1, dtype),
             $$, "custom_value", "OO", s1, dtype);
    }

custom_value_list:
  %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }
  | custom_value_list custom_value
    {
      BUILDY(DECREF($1, $2),
             $$, "handle_list", "OO", $1, $2);
    }

custom:
  DATE CUSTOM STRING custom_value_list eol key_value_list
   {
     PyObject* s1 = DateToPyDate($1);
     PyObject* s3 = StringToPyString($3);
     BUILDY(DECREF(s1, s3, $4, $6),
            $$, "custom", "OOOO", s1, s3, $4, $6);
   }

entry:
  transaction
  | balance
  | open
  | close
  | pad
  | document
  | note
  | event
  | price
  | commodity
  | query
  | custom

option:
  OPTION STRING STRING eol
    {
      PyObject* s2 = StringToPyString($2);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s2, s3),
             $$, "option", "OO", s2, s3);
    }

include:
  INCLUDE STRING eol
    {
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s2),
             $$, "include", "O", s2);
    }

plugin:
  PLUGIN STRING eol
    {
      PyObject* s2 = StringToPyString($2);
      BUILDY(DECREF(s2),
             $$, "plugin", "OO", s2, Py_None);
    }
  | PLUGIN STRING STRING eol
    {
      PyObject* s2 = StringToPyString($2);
      PyObject* s3 = StringToPyString($3);
      BUILDY(DECREF(s2, s3),
             $$, "plugin", "OO", s2, s3);
    }

directive:
  pushtag
  | poptag
  | pushmeta
  | popmeta
  | option
  | include
  | plugin

declarations:
  declarations EOL
  | declarations directive
  | declarations entry
    {
      BUILDY(DECREF($1, $2),
             $$, "handle_list", "OO", $1, $2);
    }
  | declarations error
    {
      /*
       * Ignore the error and continue reducing ({3d95e55b654e}).
       * Note that with the matching rule above, "error" will
       * successfully reduce on each line that cannot reduce.
       * Non-erroneous postings after an error occurs will reduce but
       * not be included because a transaction's list of postings
       * does not include an "error" rule.
       *
       * Note: Adding EOL after the "error" rule above works to
       * reduce the number of calls to this rule resulting from the
       * appearance of an error but makes the parser errors
       * skip the next valid directive, so we just have to make sure
       * repeated runs of this rule's handling code are idempotent.
       */
      $$ = $1;
    }
  | %empty
    {
      Py_INCREF(Py_None);
      $$ = Py_None;
    }


file:
  declarations YYEOF
    {
      BUILDY(DECREF($1),
             $$, "store_result", "O", $1);
    }

// TODO(blais): What about the 'error' token?


%%
//- User code ----------------------------------------------------------------

void beancount::parser::Parser::error(const location& loc, const string& msg)
{
  // TODO(blais): Change this code to log an error and bubble that up to the
  // output. We should never write to stderr.
  using std::cerr;
  using std::endl;
  cerr << loc << ": " << msg << endl;
  if (loc.begin.line == loc.end.line && loc.begin.line == scanner.lineno()) {
    cerr << scanner.matcher().line() << endl;
    for (size_t i = 0; i < loc.begin.column; ++i)
      cerr << " ";
    for (size_t i = loc.begin.column; i <= loc.end.column; ++i)
      cerr << "~";
    cerr << endl;
  } else {
    FILE* file = scanner.in().file(); // The current file being scanned.
    if (file != NULL) {
      beancount::scanner::Scanner::Matcher* m = scanner.new_matcher(file);
      scanner.push_matcher(m);
      off_t pos = ftell(file);
      fseek(file, 0, SEEK_SET);
      for (size_t i = 1; i < loc.begin.line; ++i) {
        m->skip('\n'); // Skip to the next line.
      }
      for (size_t i = loc.begin.line; i <= loc.end.line; ++i) {
        cerr << m->line() << endl;
        m->skip('\n'); // Next line.
      }
      fseek(file, pos, SEEK_SET); // Restore position in the file to continue scanning.
      scanner.pop_matcher(); // Restore matcher.
    }
  }

  // If token is unknown (no match).
  if (scanner.size() == 0) {
    scanner.matcher().winput(); // Skip character.
  }
}

namespace beancount {

namespace parser {

Builder::Builder(PyObject* missing_obj) :
  missing_(missing_obj)
{
}

Builder::~Builder() {
}

// TODO(blais): Implement builder methods here (maybe).

}  //  namespace parser

namespace scanner {

// An extension to the generated scanner that also fetches the filename for the
// location.
class ScannerWithFile : public scanner::Scanner {
public:
  using scanner::Scanner::Scanner;

  // Set the filename for location tokens.
  void SetFilename(const string* filename) {
    filename_ = filename;
  }

  void SetLineOffset(const int line_offset) {
    line_offset_ = line_offset;
  }

  // Override the location to include the filename.
  // TODO(blais): Why do I need this again?
  beancount::parser::location location() override
  {
    /* yylloc.begin.line = static_cast<unsigned int>(matcher().lineno()); */
    /* yylloc.begin.column = static_cast<unsigned int>(matcher().columno()); */
    /* yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end()); */
    /* yylloc.end.column = static_cast<unsigned int>(matcher().columno_end()); */
    auto yylloc = scanner::Scanner::location();
    if (filename_) {
      yylloc.begin.filename = filename_;
    }
    if (line_offset_ > 0) {
      yylloc.begin.line += line_offset_;
      yylloc.end.line += line_offset_;
    }
    return yylloc;
  }
private:
  const string* filename_ = nullptr;
  int line_offset_ = 0;
};

}  // namespace scanner

namespace parser {

// TODO(blais): Implement parser here.
/// // Parse the given input to a database.
/// std::unique_ptr<proto::Database> Parse(const reflex::Input& input,
///                                        const string* filename = nullptr,
///                                        int line_offset = 0) {
///   // Create a scanner and builder.
///   scanner::ScannerWithFile scanner(input, cout);
///   if (filename != nullptr) {
///     scanner.SetFilename(filename);
///   }
///   scanner.SetLineOffset(line_offset);
///   parser::Builder builder;
///
///   // Run the parser.
///   beancount::parser::Parser parser(scanner, builder);
///   int result = parser.parse();
///   (void)result;
///
///   auto db = builder.GetClearDatabase();
///   return db;
/// }
///
/// }  // namespace parser
///
/// std::unique_ptr<proto::Database> ParseString(const string_view& input_string,
///                                              const string_view& filename,
///                                              int line_offset) {
///   // Ensure the string is converted to UTF8 by using reflex::Input and
///   // instantiate a scanner.
///   reflex::Input input(input_string.data(), input_string.size());
///   static const string filename_str(filename);
///   return parser::Parse(input, &filename_str, line_offset);
/// }
///
/// std::unique_ptr<proto::Database> ParseFile(const string_view& filename) {
///   std::ifstream in = std::ifstream(string(filename), std::ios::in);
///   reflex::Input input(in);
///   string filename_str(filename);
///   return parser::Parse(input, &filename_str);
/// }
///
/// std::unique_ptr<proto::Database> ParseStdin() {
///   reflex::Input input(stdin, reflex::Input::file_encoding::utf8);
///   static const string filename = "<string>";
///   auto db = parser::Parse(input, &filename);
///   fclose(stdin);
///   return db;
/// }

}  // namespace parser

}  // namespace beancount

// TODO(blais): In v3 review the syntax for uniformity:
// - Allow tags/links on all directives?
// - Remove the EMPTY_SET constraint
// - Make it possible to tag/link before the narration strings.
// - In the metadata, output not just the starting line but also the end line,
//   for easy extraction of the original text.
