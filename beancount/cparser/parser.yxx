/* -*- mode: c++ -*- */
// Parser grammar for beancount 3.0 input syntax (Bison C++).

//- Options -------------------------------------------------------------------

%require "3.7"

%language "c++"
%define api.namespace {beancount::parser}
%define api.parser.class {Parser}
%define parse.error detailed
%define parse.trace

// %verbose, have to specify the output file.
// %token-table // Has no effect on C++ code generation.

%defines
%locations
%define api.filename.type "const std::string"

// %initial-action does not work to set the filename since the location() is set
// on the symbol itself.
// This doesn't work either.
// %initial-action {
//   driver.WithLocation(@$);
// }

// Input state to parser.
%parse-param {::beancount::scanner::Scanner& scanner} {::beancount::parser::Builder& builder}

//- Code blocks ---------------------------------------------------------------

// Inserted in header, before anything else
%code requires {

#include "beancount/cparser/parser.pb.h"
#include "beancount/cparser/options.pb.h"
#include "beancount/ccore/data.pb.h"
#include "beancount/ccore/number.pb.h"

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <cstdint>
#include <cstdio>
#include <fstream>
#include <list>
#include <memory>
#include <string>
#include <optional>

#include "absl/strings/string_view.h"
#include "absl/time/civil_time.h"

#include "decimal.hh"

namespace beancount {
namespace scanner { class Scanner; }
namespace parser {
class Builder;

// Parse the contents of a file.
void ParseFile(PyObject* builder_obj,
               const std::string_view& filename,
               PyObject* missing_obj);

}  // namespace parser
}  // namespace beancount
}  // %code requires

// Inserted in header, at the end.
%code provides {
}  // %code provides

//-----------------------------------------------------------------------------
// Inserted in implementation after including parser header.
%code top {

#include "beancount/cparser/scanner.h"  /* Generated by reflex. */
#include "beancount/parser/macros.h"
#include "beancount/parser/tokens.h"
#include "beancount/ccore/number.h"

#include <iostream>
#include <list>
#include <string>
#include <unordered_map>
#include <utility>

#include "absl/container/flat_hash_map.h"
#include "absl/container/flat_hash_set.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/str_format.h"
#include "absl/strings/string_view.h"
#include "reflex/input.h"

using std::string_view;
using std::cerr;
using std::cout;
using std::endl;
using std::list;
using std::pair;
using std::string;
using std::unique_ptr;
using std::vector;
using absl::StrFormat;

namespace beancount {
namespace parser {

// Default and only encoding we really have to bother supporting.
// TODO(blais): Revise this later, maybe make it part of the state of the builder.
static const char* kEncoding = "UTF-8";

// Convert string_view to Python string object.
inline PyObject* StringToPyString(const string_view s) {
  return PyUnicode_Decode(s.data(), s.size(), kEncoding, "ignore");
}

// Convert absl::CivilDay to Python date object.
inline PyObject* DateToPyDate(const absl::CivilDay& d) {
  return pydate_from_civil_day(d.year(), d.month(), d.day());
}

// Convert a decimal::Decimal to a PyDecimal.
inline PyObject* DecimalToPyDecimal(const decimal::Decimal& d) {
  return pydecimal_from_cstring(d.to_sci().c_str());
}

// Convert an Amount to a Python tuple like Amount.
// TODO(blais): This doesn't actually create a proper instance of `Amount`.
#define AmountToPyTuple(output, amount)                 \
  {                                                     \
    auto dec = ProtoToDecimal(amount->number());        \
    auto _s1 = DecimalToPyDecimal(dec);                 \
    auto _s2 = StringToPyString(amount->currency());    \
    BUILDY(DECREF(_s1, _s2),                            \
           output, "create_amount", "OO", _s1, _s2);    \
  }

// Convert a date object to an equivalent proto.
// TODO(blais): Move this to ccore.
inline void DateToProto(const absl::CivilDay& date, Date* proto) {
  assert(proto != nullptr);
  proto->set_year(date.year());
  proto->set_month(date.month());
  proto->set_day(date.day());
}

// Create two sets from a TagsLinks object.
std::tuple<PyObject*, PyObject*> TagsLinksToPython(
  inter::TagsLinks* tags_links,
  const absl::flat_hash_set<string>* active_tags) {

  assert(tags_links != nullptr);
  PyObject* tags = PySet_New(0);
  for (const auto& tag : tags_links->tags()) {
    PySet_Add(tags, StringToPyString(tag));
  }
  PyObject* links = PySet_New(0);
  for (const auto& link : tags_links->links()) {
    PySet_Add(links, StringToPyString(link));
  }

  // Add the set of active tags if provided.
  if (active_tags != nullptr) {
    for (const auto& tag : *active_tags) {
      PySet_Add(tags, StringToPyString(tag));
    }
  }

  return {tags, links};
}

/*
 * Call a builder method and detect and handle a Python exception being raised
 * in the handler. Always run the code to clean the references provided by the
 * reduced rule. {05bb0fb60e86}
 */
#define BUILDY(clean, target, method_name, format, ...)                                         \
  {                                                                                             \
    auto loc = scanner.location();                                                              \
    /* cerr << "method_name: " << method_name << endl */                                        \
    /*     << "filename: " << *loc.begin.filename << ":" << loc.begin.line << endl; */          \
    target = PyObject_CallMethod(builder.builder(), method_name, "si" format,                   \
                                 loc.begin.filename->c_str(),                                   \
                                 loc.begin.line,                                                \
                                 ## __VA_ARGS__);                                               \
    clean;                                                                                      \
                                                                                                \
    if (target == NULL) {                                                                       \
      /* TODO(blais): This is for temporary debugging of internal errors while porting. */      \
      PyErr_PrintEx(1);                                                                         \
                                                                                                \
      build_grammar_error_from_exception(loc, builder.builder());                               \
      /* Figure out if this is stilil the right way to call for errors in the C++ parser. */    \
      YYERROR;                                                                                  \
    }                                                                                           \
  }

/* Build a grammar error from the exception context. */
void build_grammar_error_from_exception(const location& loc, PyObject* builder) {
  cerr << "build_grammar_error_from_exception " << loc << endl;
  assert(builder != nullptr);

  /* Get the exception context. */
  PyObject* ptype;
  PyObject* pvalue;
  PyObject* ptraceback;
  PyErr_Fetch(&ptype, &pvalue, &ptraceback);
  PyErr_NormalizeException(&ptype, &pvalue, &ptraceback);

  /* Clear the exception. */
  PyErr_Clear();

  if (pvalue != NULL) {
    /* Build and accumulate a new error object. {27d1d459c5cd} */
    PyObject* rv = PyObject_CallMethod(builder, "build_grammar_error", "OiOOO",
                                       loc.begin.filename, loc.begin.line,
                                       pvalue, ptype, ptraceback);
    if (rv == NULL) {
      /* Note: Leave the internal error trickling up its detail. */
      /* PyErr_SetString(PyExc_RuntimeError, */
      /*                 "Internal error: While building exception"); */
    }
  }
  else {
    PyErr_SetString(PyExc_RuntimeError,
                    "Internal error: No exception");
  }

  Py_XDECREF(ptype);
  Py_XDECREF(pvalue);
  Py_XDECREF(ptraceback);
}

// TODO(blais): Move this to error() code.
#if 0
/* Error-handling function. {ca6aab8b9748} */
void yyerror(const location& loc, yyscan_t scanner, PyObject* builder, char const* message)
{
  /* Register a syntax error with the builder. */
  PyObject* rv = PyObject_CallMethod(builder, "build_grammar_error", "Ois",
                                     loc->file_name, loc->first_line,
                                     message);
  if (rv == NULL) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Internal error: Building exception from yyerror()");
  }
  Py_XDECREF(rv);
}
#endif

#define DECREF(...) _CC_FUNC(Py_DECREF, __VA_ARGS__)

// In-memory build state for graph of nodes. This driver accepts actions from
// the parser and simply builds up the parsed state. Since the input is not
// assumed to be ordered, resolving references occurs as a separate phase.
class Builder {
public:
  Builder(scanner::Scanner& scanner, PyObject* builder_obj, PyObject* missing_obj);
  virtual ~Builder() {}

  void Initialize() {
    //// kAccountRE(StrFormat("(?:%s)(?:%s%s)+",
  }

  inline PyObject* builder() const { return builder_obj_; }
  inline PyObject* missing() const { return missing_obj_; }
  const absl::flat_hash_set<string>& active_tags() const { return active_tags_; }
  const absl::flat_hash_map<string, vector<MetaValue*>>& active_meta() const {
    return active_meta_;
  }

  void AddOption(string_view key, string_view value) {
    // TODO(blais): Convert Python code to C++ here.

    const auto* descriptor = options_->GetDescriptor();
    if (!descriptor->FindFieldByName(string(key))) {
      // LogError(
    // if key not in self.options:
    //     meta = new_metadata(filename, lineno)
    //     self.errors.append(
    //         ParserError(meta, "Invalid option: '{}'".format(key), None))

    }

    // elif key in options.READ_ONLY_OPTIONS:
    //     meta = new_metadata(filename, lineno)
    //     self.errors.append(
    //         ParserError(meta, "Option '{}' may not be set".format(key), None))

    // else:
    //     option_descriptor = options.OPTIONS[key]

    //     # Issue a warning if the option is deprecated.
    //     if option_descriptor.deprecated:
    //         assert isinstance(option_descriptor.deprecated, str), "Internal error."
    //         meta = new_metadata(filename, lineno)
    //         self.errors.append(
    //             DeprecatedError(meta, option_descriptor.deprecated, None))

    //     # Rename the option if it has an alias.
    //     if option_descriptor.alias:
    //         key = option_descriptor.alias
    //         option_descriptor = options.OPTIONS[key]

    //     # Convert the value, if necessary.
    //     if option_descriptor.converter:
    //         try:
    //             value = option_descriptor.converter(value)
    //         except ValueError as exc:
    //             meta = new_metadata(filename, lineno)
    //             self.errors.append(
    //                 ParserError(meta,
    //                             "Error for option '{}': {}".format(key, exc),
    //                             None))
    //             return

    //     option = self.options[key]
    //     if isinstance(option, list):
    //         # Append to a list of values.
    //         option.append(value)

    //     elif isinstance(option, dict):
    //         # Set to a dict of values.
    //         if not (isinstance(value, tuple) and len(value) == 2):
    //             self.errors.append(
    //                 ParserError(
    //                     meta, "Error for option '{}': {}".format(key, value), None))
    //             return
    //         dict_key, dict_value = value
    //         option[dict_key] = dict_value

    //     elif isinstance(option, bool):
    //         # Convert to a boolean.
    //         if not isinstance(value, bool):
    //             value = (value.lower() in {'true', 'on'}) or (value == '1')
    //         self.options[key] = value

    //     else:
    //         # Set the value.
    //         self.options[key] = value

    //     # Refresh the list of valid account regexps as we go along.
    //     if key.startswith('name_'):
    //         # Update the set of valid account types.
    //         self.account_regexp = valid_account_regexp(self.options)
    //     elif key == 'insert_pythonpath':
    //         # Insert the PYTHONPATH to this file when and only if you
    //         # encounter this option.
    //         sys.path.insert(0, path.dirname(filename))

  }

  void AddInclude(string_view filename) {
    info_->add_include(filename.data(), filename.size());
  }

  void AddPlugin(string_view name, optional<string_view> config) {
    auto* plugin = info_->add_plugin();
    plugin->set_name(name.data(), name.size());
    if (config.has_value()) {
      plugin->set_config(config.value().data(), config.value().size());
    }
  }

  // Update the given repeated field with the list of active tags.
  // This function mutates the given argument.
  void SetTags(const google::protobuf::RepeatedPtrField<std::string>& tags,
               google::protobuf::RepeatedPtrField<std::string>* output) {
    // First copy the active tags.
    for (const auto& active_tag : active_tags_) {
      *output->Add() = active_tag;
    }
    // Add the new tags, avoiding duplicates.
    for (const auto& tag : tags) {
      if (active_tags_.find(tag) == active_tags_.end()) {
        *output->Add() = tag;
      }
    }
  }

  // // Set the location for errors to occur.
  // // This is a stateful setter whose data get used to report errors.
  // void WithLocation(const parser::location& location) {
  //   location_ = location;
  // }

  // TODO(blais): Create an updated driver for Beancount.

  // TODO(blais): Remove this and replace it with post-parsing verification.
  string_view Account(string_view account) {
    accounts_.insert({account.data(), account.size()});
    return account;
  }

  void PushTag(string_view tag) {
    active_tags_.insert({tag.data(), tag.size()});
  }

  void PopTag(string_view tag) {
    auto iter = active_tags_.find({tag.data(), tag.size()});
    if (iter != active_tags_.end()) {
      active_tags_.erase(iter);
    } else {
      LogError(StrFormat("Attempting to pop absent tag: '%s'", tag));
    }
  }

  // Steal the reference to `value`.
  void PushMeta(string_view key, MetaValue* value) {
    auto& value_list = active_meta_[key];
    value_list.push_back(value);
  }

  void PopMeta(string_view key) {
    auto iter = active_meta_.find(key);
    if (iter == active_meta_.end()) {
      LogError(StrFormat("Attempting to pop absent metadata key: '%s'", key));
    } else {
      auto& value_list = iter->second;
      assert(value_list.size() > 0);
      auto* value = value_list.back();
      value_list.pop_back();
      if (value_list.empty()) {
        active_meta_.erase(iter);
      }
      delete value;
    }
  }

  // Insert the active metadata into the given argument.
  void AddActiveMetadata(beancount::Meta* meta, beancount::Meta* output) {
    // Insert active metadata.
    for (auto [key, value_list] : active_meta_) {
      auto* kv = output->mutable_kv()->Add();
      kv->set_key(key);
      kv->mutable_value()->CopyFrom(*value_list.back());
    }

    // Merge given metadata on top of active metadttaa.
    if (meta != nullptr) {
      output->MergeFrom(*meta);
    }

    // TODO(blais): Check for the presence of duplicates in the loop above and
    // log and error if found.
    //
    //  value = explicit_meta.setdefault(posting_or_kv.key,
    //                                   posting_or_kv.value)
    //  if value is not posting_or_kv.value:
    //      self.errors.append(ParserError(
    //          meta, "Duplicate metadata field on entry: {}".format(
    //              posting_or_kv), None))
    //
  }

  void UpdatePrecisionStats(const decimal::Decimal& dec, string_view currency) {
    // TODO(blais): Update display context stats. See grammar.Builder.dcupdate().
  }

  // Common posting preparation actions.
  void PreparePosting(inter::Posting* posting,
                      const char flag,
                      string_view account,
                      bool is_total,
                      const location& loc) {
    assert(posting != nullptr);

    // Store flag and account name.
    posting->set_flag(&flag);
    posting->set_account(account.data(), account.size());

    // Store filename and line number in metadata.
    {
      auto* kv = posting->mutable_meta()->add_kv();
      kv->set_key("filename");
      assert(loc.begin.filename != nullptr);
      kv->mutable_value()->set_text(loc.begin.filename->data(), loc.begin.filename->size());
    }
    {
      auto* kv = posting->mutable_meta()->add_kv();
      kv->set_key("lineno");
      kv->mutable_value()->set_integer(loc.begin.line);
    }

    // Check conditions renamed to price annotations.
    if (posting->has_price()) {
      const auto& price = posting->price();

      // If the price is specified for the entire amount, compute the effective
      // price here and forget about that detail of the input syntax.
      if (is_total) {
        if (!posting->has_units() || !posting->units().has_number()){
          // units.number is MISSING.
          // Note: we could potentially do a better job and attempt to f
          // this up after interpolation, but this syntax is pretty rare
          // anyway.
          LogError(StrFormat("Total price on a posting without units: %s.",
                             price.DebugString()));
          posting->clear_price();
        } else if (price.has_number()) {
          decimal::Decimal dunits = ProtoToDecimal(posting->units().number());
          decimal::Decimal dprice;
          if (dunits.iszero()) {
            dprice = dunits;
          } else {
            dprice = ProtoToDecimal(price.number()) / dunits.abs();
          }
          DecimalToProto(dprice, posting->mutable_price()->mutable_number());
        }
      }

      // Note: Allow zero prices because we need them for round-trips for
      // conversion entries.
      //
      // if price is not None and price.number == ZERO:
      //     self.errors.append(
      //         ParserError(meta, "Price is zero: {}".format(price), None))

      // If both cost and price are specified, the currencies must match, or
      // that is an error.
      if (posting->has_cost_spec() &&
          posting->cost_spec().has_currency() &&
          price.has_currency() &&
          posting->cost_spec().currency() != price.currency()) {
        LogError(StrFormat("Cost and price currencies must match: %s != %s",
                           posting->cost_spec().currency(), price.currency()));
      }
    }
  }

  // Note: We steal ownership.
  void AppendDirective(inter::Directive*& directive) {
    directives_.push_back(directive);
    directive = nullptr;
  }

  // Insert an error in the error log. These will be returned along with the
  // ledger as output of the parsing phase.
  void LogError(string_view message) {
    // TODO(blais):
    /// scanner_.location()
  }
  // TODO(blais): Can we turn this error logging into a stream instead?

  // Check that all the accounts are matching the prefix names provided in the
  // options.
  void ValidateAccount_names() {
  // TODO(blais):
    // if not self.account_regexp.match(account):
    //     meta = new_metadata(filename, lineno)
    //     self.errors.append(
    //         ParserError(meta, "Invalid account name: {}".format(account), None))
  }

  void Finalize() {
    void ValidateAccountNames();

    // If the user left some tags unbalanced, issue an error.
    for (const auto& tag : active_tags_) {
      LogError(StrFormat("Unbalanced pushed tag: '%s'", tag));
    }

    // If the user left some metadata unpopped, issue an error.
    for (const auto& [key, value_list] : active_meta_) {
      LogError(StrFormat(
                 "Unbalanced metadata key '%s' has leftover metadata", key));
    }
  }

private:
  // Scanner (in order to get the last location).
  scanner::Scanner scanner_;

  // Processing info to produce from the parser.
  std::unique_ptr<options::ProcessingInfo> info_;

  // Options parsed.
  std::unique_ptr<options::Options> options_;

  // Python grammar builder object.
  PyObject* builder_obj_;

  // beancount.core.number.MISSING object.
  PyObject* missing_obj_ = nullptr;

  // A set of all unique account names seen in the file.
  absl::flat_hash_set<string> accounts_;

  // A set of active tags.
  absl::flat_hash_set<string> active_tags_;

  // A dict of the current active metadata fields; each of the field values is a
  // stack and the current value is at the top (last value).
  absl::flat_hash_map<string, vector<MetaValue*>> active_meta_;

  // The accumulated list of all directives.
  vector<inter::Directive*> directives_;
};

}  // namespace parser
}  // namespace beancount
}  // %code top

// Inserted in implementation before including parser header
// (Within bison's parse() we should invoke lexer.lex(), not the global yylex().)
%code {
#undef yylex
#define yylex scanner.lex
}

//- Tokens --------------------------------------------------------------------
// Note: Token type names appear in the parser header; qualify fully.

/* Collection of value types. */
%define api.value.type variant // See: "C++ Variants"
%define api.token.constructor
%define api.token.prefix {TOK_}

/* Special error token, redefined to carry an error message. */
%token <std::string_view> error

/* Types for terminal symbols */
%token INDENT     /* Initial indent IF at the beginning of a line */
%token DEDENT     /* Initial indent IF at the beginning of a line */
%token EOL        /* End-of-line */
%token PIPE       /* | */
%token ATAT       /* @@ */
%token AT         /* @ */
%token LCURLCURL  /* {{ */
%token RCURLCURL  /* }} */
%token LCURL      /* { */
%token RCURL      /* } */
%token COMMA      /* , */
%token TILDE      /* ~ */
%token HASH       /* # */
%token ASTERISK   /* * */
%token SLASH      /* / */
%token COLON      /* : */
%token PLUS       /* + */
%token MINUS      /* - */
%token LPAREN     /* ( */
%token RPAREN     /* ) */
%token <char> FLAG    /* Valid characters for flags */
%token TXN                 /* 'txn' keyword */
%token BALANCE             /* 'balance' keyword */
%token OPEN                /* 'open' keyword */
%token CLOSE               /* 'close' keyword */
%token COMMODITY           /* 'commodity' keyword */
%token PAD                 /* 'pad' keyword */
%token EVENT               /* 'event' keyword */
%token PRICE               /* 'price' keyword */
%token NOTE                /* 'note' keyword */
%token DOCUMENT            /* 'document' keyword */
%token QUERY               /* 'query' keyword */
%token CUSTOM              /* 'custom' keyword */
%token PUSHTAG             /* 'pushtag' keyword */
%token POPTAG              /* 'poptag' keyword */
%token PUSHMETA            /* 'pushmeta' keyword */
%token POPMETA             /* 'popmeta' keyword */
%token OPTION              /* 'option' keyword */
%token INCLUDE             /* 'include' keyword */
%token PLUGIN              /* 'plugin' keyword */
%token NONE        /* A None value (parsed as NULL) */
%token <bool> BOOL        /* A boolean, true or false */
%token <absl::CivilDay> DATE        /* A date object */
%token <decimal::Decimal> NUMBER      /* A decimal number */
%token <std::string_view> ACCOUNT     /* The name of an account */
%token <std::string_view> CURRENCY    /* A currency specification */
%token <std::string_view> STRING      /* A quoted string, with any characters inside */
%token <std::string_view> TAG         /* A tag that can be associated with a transaction */
%token <std::string_view> LINK        /* A link that can be associated with a transaction */
%token <std::string_view> KEY         /* A key in a key-value pair */

/* Types for non-terminal symbols. */
%type <char> txn
%type <char> optflag
%type <std::string_view> account

%type <beancount::inter::Directive*> transaction_line

%type <std::vector<beancount::inter::Posting*>> posting_list
%type <beancount::inter::Posting*> posting_and_metadata
%type <beancount::inter::Posting*> posting

%type <beancount::Meta*> indented_metadata
%type <beancount::Meta*> metadata
%type <beancount::Meta::KV*> metadata_line
%type <beancount::MetaValue*> meta_value
%type <std::vector<beancount::MetaValue*>> meta_value_list

/* TODO(blais): Add constness aggressively. The produced tokens can be const. */
%type <std::vector<std::string>> currency_list
%type <std::pair<const beancount::Amount*, std::optional<decimal::Decimal>>> amount_tolerance
%type <beancount::Amount*> amount
%type <beancount::Amount*> incomplete_amount
%type <std::optional<decimal::Decimal>> maybe_number
%type <std::optional<std::string_view>> maybe_currency
%type <beancount::Amount*> price_annotation
%type <beancount::inter::CostSpec*> compound_amount
%type <beancount::inter::CostSpec*> cost_comp
%type <beancount::inter::CostSpec*> cost_comp_list
%type <beancount::inter::CostSpec*> cost_spec

%type <beancount::inter::Directive*> directive
%type <beancount::inter::Directive*> transaction
%type <beancount::inter::Directive*> balance
%type <beancount::inter::Directive*> open
%type <beancount::inter::Directive*> close
%type <beancount::inter::Directive*> pad
%type <beancount::inter::Directive*> document
%type <beancount::inter::Directive*> note
%type <beancount::inter::Directive*> event
%type <beancount::inter::Directive*> price
%type <beancount::inter::Directive*> commodity
%type <beancount::inter::Directive*> query
%type <beancount::inter::Directive*> custom

%type <std::pair<std::string, std::string>> payee_narration
%type <beancount::inter::TagsLinks*> tags_links
%type <std::string_view> filename
%type <Booking> booking
%type <decimal::Decimal> number_expr

%type option
%type include
%type plugin

%type pushtag
%type poptag
%type pushmeta
%type popmeta

%type file
%type declarations

/* Operator precedence.
 * This is pulled straight out of the textbook example:
 * https://www.gnu.org/software/bison/manual/html_node/Infix-Calc.html#Infix-Calc
 */
%left MINUS PLUS
%left ASTERISK SLASH
%precedence NEGATIVE /* negation--unary minus */

/* Start symbol. */
%start file

/* We have some number of expected shift/reduce conflicts at 'eol'. */
/* TODO(blais): Have another go at taking to zero. */
%expect 19



//- Grammar rules -------------------------------------------------------------
%%


/* A transaction declaration can be either 'txn' or one of the special character flags. */
txn:
  TXN
    {
      $$ = '*';
    }
  | FLAG
    {
        $$ = $1;
    }
  | ASTERISK
    {
        $$ = '*';
    }
  | HASH
    {
        $$ = '#';
    }

eol: EOL | YYEOF

/* FIXME: This needs be made more general, dealing with precedence.
   I just need this right now, so I'm putting it in, in a way that will.
   be backwards compatible, so this is just a bit of a temporary hack
   (blais, 2015-04-18). */
number_expr:
  NUMBER
  | number_expr PLUS number_expr
    {
      $$ = $1.add($3);
    }
  | number_expr MINUS number_expr
    {
      $$ = $1.sub($3);
    }
  | number_expr ASTERISK number_expr
    {
      $$ = $1.mul($3);
    }
  | number_expr SLASH number_expr
    {
      $$ = $1.div($3);
    }
  | MINUS number_expr %prec NEGATIVE
    {
      $$ = $2.minus();
    }
  | PLUS number_expr %prec NEGATIVE
    {
      $$ = $2.plus(); // Note: Not entirely sure we shouldn't just copy.
    }
  | LPAREN number_expr RPAREN
    {
      $$ = $2;
    }

/* Payee and narration. */
payee_narration:
  /* Variant when both strings are present. */
  STRING STRING
    {
      $$ = make_pair($1, $2);
    }
  /* Variant when only one string is present; interpret as narration only. */
  | STRING
    {
      $$ = make_pair("", $1);
    }

tags_links:
  %empty
    {
      $$ = new inter::TagsLinks{};
    }
  | tags_links LINK
    {
      $1->add_links($2.data(), $2.size());
      $$ = $1;
    }
  | tags_links TAG
    {
      $1->add_tags($2.data(), $2.size());
      $$ = $1;
    }

/* A full matched transaction. */
transaction:
  /* A transaction with no indented body (this is valid). */
  transaction_line
    {
      $$ = $1;
    }
  /* A transaction with an indented body. */
  | transaction_line INDENT metadata posting_list DEDENT
    {
      $$ = $1;

      // Insert the local metadata on top of that from the directive.
      // {99ef4ca51cd5}
      if ($metadata != nullptr) {
        $$->mutable_meta()->MergeFrom(*$metadata);
        delete $metadata;
      }

      // Attach postings to the directive.
      auto* txn = $$->mutable_transaction();
      for (const auto* posting : $posting_list) {
        txn->mutable_postings()->Add()->CopyFrom(*posting);
      }
    }

/* Matches just the first line of a transaction, without its metadata. */
transaction_line:
  DATE txn payee_narration[pn] tags_links eol
    {
      // Create directive and update head, without custom metadata. That is
      // added at {99ef4ca51cd5}.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata(nullptr, dir->mutable_meta());

      // Create Transaction and update flag.
      auto* txn = dir->mutable_transaction();
      txn->set_flag(&$txn);

      // Update payee and narration fields.
      if (!$pn.first.empty()) {
        txn->set_payee($pn.first.data(), $pn.first.size());
      }
      if (!$pn.second.empty()) {
        txn->set_narration($pn.second.data(), $pn.second.size());
      }

      // Update tags, including active tags and links.
      builder.SetTags($tags_links->tags(), txn->mutable_tags());
      txn->mutable_links()->CopyFrom($tags_links->links());
      delete $tags_links;
    }

optflag:
  %empty
    {
      $$ = '\0';
    }
  | ASTERISK
    {
      $$ = '*';
    }
  | HASH
    {
      $$ = '#';
    }
  | FLAG

price_annotation:
  incomplete_amount
    {
      $price_annotation = $incomplete_amount;

      // Prices may not be negative. Check and issue an error if found; fix up
      // the price to its absolute value and continue.
      if ($price_annotation->has_number()) {
        decimal::Decimal dec = ProtoToDecimal($price_annotation->number());
        if (dec.sign() == -1) {
          builder.LogError("Negative prices are not allowed "
                           "(see http://furius.ca/beancount/doc/bug-negative-prices "
                           "for workaround)");
          // Invert and continue.
          DecimalToProto(-dec, $price_annotation->mutable_number());
        }
      }
    }

account:
  ACCOUNT
    {
      $$ = builder.Account($1);
    }


/* A list of metadata (optionally empty), including its indentation. */
indented_metadata:
  %empty
    {
      $$ = nullptr;
    }
  | INDENT metadata DEDENT
    {
      $$ = $2;
    }

/* A list of metadata (optionally empty). */
metadata:
  %empty
    {
      $$ = nullptr;
    }
  | metadata metadata_line
    {
      if ($1 == nullptr) {
        $$ = new beancount::Meta();
      } else {
        $$ = $1;
      }
      auto* kv = $$->add_kv();
      kv->CopyFrom(*$2);
      delete $2;
    }

/* A single line of a metadata declaration. */
metadata_line:
  /* Regular key-value pairs. */
  KEY COLON meta_value eol
    {
      $$ = new beancount::Meta::KV();
      $$->set_key($1.data(), $1.size());
      $$->mutable_value()->CopyFrom(*$3);
      delete $3;
    }
  /* A tag can be used by itself as metadata. */
  | TAG eol
    {
      $$ = new beancount::Meta::KV();
      $$->mutable_value()->set_tag($1.data(), $1.size());
    }
  /* A link can be used by itself as metadata. */
  | LINK eol
    {
      $$ = new beancount::Meta::KV();
      $$->mutable_value()->set_link($1.data(), $1.size());
    }

/* A list of postings, possibly empty. */
posting_list:
  %empty
    {
      $$ = {};
    }
  /* Matches an empty or comment indented line. It's convenient to be able to
   * comment indented postings. */
  | posting_list eol
  /* Matches an actual posting. */
  | posting_list posting_and_metadata
    {
      $1.push_back($2);
      $$ = $1;
    }

/* A single posting and its associated metadata. */
posting_and_metadata:
  posting indented_metadata
    {
      if ($2 != nullptr) {
        $1->mutable_meta()->CopyFrom(*$2);
        delete $2;
      }
      $$ = $1;
    }

/* A posting line, without any of its metadata. */
posting:
  /* Variation with no price. */
  optflag account incomplete_amount cost_spec eol
    {
      $$ = new inter::Posting();
      $$->mutable_units()->CopyFrom(*$incomplete_amount);
      $$->mutable_cost_spec()->CopyFrom(*$cost_spec);
      builder.PreparePosting($$, $optflag, $account, false, scanner.location());
    }
  /* Variation with price. */
  | optflag account incomplete_amount cost_spec AT price_annotation eol
    {
      $$ = new inter::Posting();
      $$->mutable_units()->CopyFrom(*$incomplete_amount);
      $$->mutable_cost_spec()->CopyFrom(*$cost_spec);
      $$->mutable_price()->CopyFrom(*$price_annotation);
      builder.PreparePosting($$, $optflag, $account, false, scanner.location());
    }
  /* Variation with complete price. */
  | optflag account incomplete_amount cost_spec ATAT price_annotation eol
    {
      // TODO(blais): Merge this rule with the one above, by inspecting the
      // value of AT and ATAT.
      $$ = new inter::Posting();
      $$->mutable_units()->CopyFrom(*$incomplete_amount);
      $$->mutable_cost_spec()->CopyFrom(*$cost_spec);
      $$->mutable_price()->CopyFrom(*$price_annotation);
      builder.PreparePosting($$, $optflag, $account, true, scanner.location());
    }
  /* Variation with just an account name. */
  | optflag account eol
    {
      $$ = new inter::Posting();
      builder.PreparePosting($$, $optflag, $account, false, scanner.location());
    }

meta_value:
  STRING
    {
      $$ = new beancount::MetaValue();
      $$->set_text($1.data(), $1.size());
    }
  | CURRENCY
    {
      $$ = new beancount::MetaValue();
      $$->set_currency($1.data(), $1.size());
    }
  | account
    {
      $$ = new beancount::MetaValue();
      $$->set_account($1.data(), $1.size());
    }
  | TAG
    {
      $$ = new beancount::MetaValue();
      $$->set_tag($1.data(), $1.size());
    }
  | LINK
    {
      $$ = new beancount::MetaValue();
      $$->set_link($1.data(), $1.size());
    }
  | DATE
    {
      $$ = new beancount::MetaValue();
      DateToProto($1, $$->mutable_date());
    }
  | BOOL
    {
      $$ = new beancount::MetaValue();
      $$->set_boolean($1);
    }
  | NONE
    {
      $$ = new beancount::MetaValue();
      /* NULL is a proto not set */
    }
  | number_expr
    {
      $$ = new beancount::MetaValue();
      DecimalToProto($1, $$->mutable_number());
    }
  /* TODO(blais): Bring this back once 'amount' has been ported. */
  // | amount
  //   {
  //     $$ = new beancount::MetaValue();
  //     DecimalToProto($1, $$->mutable_number());
  //   }
  | %empty
    {
      $$ = new beancount::MetaValue();
    }

meta_value_list:
  %empty
    {
      $$ = {};
    }
  | meta_value_list meta_value
    {
      $$ = $1;
      $$.push_back($2);
    }

currency_list:
  %empty
    {
      $$ = {};
    }
  | CURRENCY
    {
      $$.push_back({$1.data(), $1.size()});
    }
  | currency_list COMMA CURRENCY
    {
      $$ = $1;
      $$.push_back({$3.data(), $3.size()});
    }

pushtag:
  PUSHTAG TAG eol
    {
      builder.PushTag($2);
    }

poptag:
  POPTAG TAG eol
    {
      builder.PopTag($2);
    }

pushmeta:
  PUSHMETA KEY COLON meta_value eol
    {
      builder.PushMeta($2, $4);
    }

popmeta:
  POPMETA KEY COLON eol
    {
      builder.PopMeta($2);
    }

open:
  DATE OPEN account currency_list booking eol indented_metadata
    {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Open and update account.
      auto* open = dir->mutable_open();
      open->set_account($account.data(), $account.size());

      // Create currency list.
      for (const auto& currency : $currency_list) {
        open->add_currencies(currency);
      }

      // Set booking method.
      open->set_booking($booking);
    }

booking:
  STRING
    {
      string s1($1.data(), $1.size());
      Booking method;
      if (!Booking_Parse(s1, &method)) {
        builder.LogError(StrFormat("Invalid value for booking method: '%s'", s1));
        // TODO(blais): For v2 behavior, set this to the global default.
        method = Booking::UNKNOWN;
      }
      $$ = method;
    }
  | %empty
    {
      $$ = Booking::UNKNOWN;
    }

close:
  DATE CLOSE account eol indented_metadata
    {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Close and update account.
      auto* open = dir->mutable_close();
      open->set_account($account.data(), $account.size());
    }

commodity:
  DATE COMMODITY CURRENCY eol indented_metadata
    {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Commodity and update account.
      auto* commodity = dir->mutable_commodity();
      commodity->set_currency($CURRENCY.data(), $CURRENCY.size());
    }

pad:
  DATE PAD account account[source] eol indented_metadata
    {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Pad and update accounts.
      auto* pad = dir->mutable_pad();
      pad->set_account($3.data(), $3.size());
      pad->set_source_account($source.data(), $source.size());
    }

balance:
  DATE BALANCE account amount_tolerance[atol] eol indented_metadata[meta]
    {
      // Create directive and prepare head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      if ($meta != nullptr) {
        dir->mutable_meta()->CopyFrom(*$meta);
        delete $meta;
      }

      // Create Pad and fill in account.
      auto* balance = dir->mutable_balance();
      balance->set_account($account.data(), $account.size());

      // Fill in amount.
      balance->mutable_amount()->CopyFrom(*$atol.first);
      delete $atol.first;

      // Fill in optional tolerance.
      if ($atol.second.has_value()) {
        DecimalToProto($atol.second.value(), balance->mutable_tolerance());
      }

      // Note: We leave `diff_amount` unset.
    }

/* An Amount, which is a decimal number and a currency. */
amount:
  number_expr CURRENCY
    {
      auto* amount = new Amount();
      DecimalToProto($1, amount->mutable_number());
      amount->set_currency($2.data(), $2.size());
      $$ = amount;
      builder.UpdatePrecisionStats($1, $2);
    }

/* An amount, with an optional associated tolerance. */
amount_tolerance:
  amount
    {
      $$ = make_pair($1, std::optional<decimal::Decimal>{});
    }
  | number_expr TILDE number_expr[tolerance] CURRENCY
    {
      auto* amount = new Amount();
      DecimalToProto($1, amount->mutable_number());
      amount->set_currency($4.data(), $4.size());
      $$ = make_pair(amount, $tolerance);
      builder.UpdatePrecisionStats($1, $4);
      builder.UpdatePrecisionStats($tolerance, $4);
    }

maybe_number:
  number_expr
    {
      $$ = {$1};
    }
  | %empty
    {
      $$ = {};
    }

maybe_currency:
  CURRENCY
    {
      $$ = {$1};
    }
  | %empty
    {
      $$ = {};
    }

compound_amount:
  maybe_number CURRENCY
    {
      $$ = new inter::CostSpec();
      if ($1.has_value()) {
        DecimalToProto($1.value(), $$->mutable_number_per());
        builder.UpdatePrecisionStats($1.value(), $2);
      }
      $$->set_currency({$2.data(), $2.size()});
    }
  | number_expr maybe_currency
    {
      $$ = new inter::CostSpec();
      DecimalToProto($1, $$->mutable_number_per());
      if ($2.has_value()) {
        $$->set_currency({$2.value().data(), $2.value().size()});
        builder.UpdatePrecisionStats($1, $2.value());
      }
    }
  | maybe_number HASH maybe_number CURRENCY
    {
      $$ = new inter::CostSpec();
      if ($1.has_value()) {
        DecimalToProto($1.value(), $$->mutable_number_per());
        builder.UpdatePrecisionStats($1.value(), $4);
      }
      if ($3.has_value()) {
        DecimalToProto($3.value(), $$->mutable_number_total());
        builder.UpdatePrecisionStats($3.value(), $4);
      }
      $$->set_currency({$4.data(), $4.size()});
    }

incomplete_amount:
  maybe_number maybe_currency
    {
      $$ = new Amount();
      if ($1.has_value()) {
        DecimalToProto($1.value(), $$->mutable_number());
      }
      if ($2.has_value()) {
        $$->set_currency($2.value().data(), $2.value().size());
      }
    }

cost_spec:
  LCURL cost_comp_list RCURL
    {
      $$ = $2;
    }
  | LCURLCURL cost_comp_list RCURLCURL
    {
      // Note: This is using the total syntax; it is an error to set
      // `number_total` to a value in the input when using `{{...}}`.
      if ($2->has_number_total()) {
        builder.LogError(
          StrFormat("Per-unit cost may not be specified using total cost "
                    "syntax: '%s'; ignoring per-unit cost", $2->DebugString()));
      } else {
        $2->mutable_number_total()->CopyFrom($2->number_per());
      }
      $2->clear_number_per();
      $$ = $2;
    }
  | %empty
    {
      $$ = new inter::CostSpec();
    }

cost_comp_list:
  %empty
    {
      $$ = new inter::CostSpec();
    }
  | cost_comp
  | cost_comp_list COMMA cost_comp
    {
      // Note: Assuming we are allowed to return and mutate $1.
      $$ = $1;
      // TODO(blais): Check for collisions here.
      $$->MergeFrom(*$3);
      delete $3;
    }

cost_comp:
  compound_amount
  | DATE
    {
      $$ = new inter::CostSpec();
      DateToProto($1, $$->mutable_date());
    }
  | STRING
    {
      $$ = new inter::CostSpec();
      $$->set_label($1.data(), $1.size());
    }
  | ASTERISK
    {
      $$ = new inter::CostSpec();
      $$->set_merge_cost(true);
    }

price:
  DATE PRICE CURRENCY amount eol indented_metadata
    {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Price and update currency.
      auto* price = dir->mutable_price();
      price->set_currency($3.data(), $3.size());

      // Update price amount.
      price->mutable_amount()->CopyFrom(*$amount);
    }

event:
  DATE EVENT STRING[type] STRING[description] eol indented_metadata
    {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Event and update fields.
      auto* event = dir->mutable_event();
      event->set_type($type.data(), $type.size());
      event->set_description($description.data(), $description.size());
    }

query:
  DATE QUERY STRING[name] STRING[qstr] eol indented_metadata
    {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Query and update fields.
      auto* query = dir->mutable_query();
      query->set_name($name.data(), $name.size());
      query->set_query_string($qstr.data(), $qstr.size());
    }

note:
  DATE NOTE account STRING[comment] eol indented_metadata
    {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Note and update account.
      auto* note = dir->mutable_note();
      note->set_account($3.data(), $3.size());

      // Fill in comment.
      note->set_comment($comment.data(), $comment.size());
    }

filename:
  STRING

document:
  DATE DOCUMENT account filename tags_links eol indented_metadata
    {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Document and update account and filename.
      auto* document = dir->mutable_document();
      document->set_account($account.data(), $account.size());
      document->set_filename($filename.data(), $filename.size());

      // Update tags, including active tags, and links.
      // TODO(blais): Refactor with txn? It's the same code.
      builder.SetTags($tags_links->tags(), document->mutable_tags());
      document->mutable_links()->CopyFrom($tags_links->links());
      delete $tags_links;
    }

custom:
  DATE CUSTOM STRING[type] meta_value_list eol indented_metadata
   {
      // Create directive and update head.
      auto* dir = $$ = new inter::Directive();
      DateToProto($DATE, dir->mutable_date());
      builder.AddActiveMetadata($indented_metadata, dir->mutable_meta());
      delete $indented_metadata;

      // Create Custom and update accounts.
      auto* custom = dir->mutable_custom();
      custom->set_type($type.data(), $type.size());

      // Copy custom values here.
      for (const auto* meta_value : $meta_value_list) {
        // TODO(blais): Will AddAllocated() work here?
        custom->mutable_values()->Add()->CopyFrom(*meta_value);
        delete meta_value;
      }
      $meta_value_list.clear();
   }

/* A rule to reduce any of the Beancount directives we offer. */
directive:
  transaction
  | balance
  | open
  | close
  | pad
  | document
  | note
  | event
  | price
  | commodity
  | query
  | custom

option:
  OPTION STRING[key] STRING[value] eol
    {
      builder.AddOption($key, $value);
    }

include:
  INCLUDE STRING eol
    {
      builder.AddInclude($2);
    }

plugin:
  PLUGIN STRING eol
    {
      builder.AddPlugin($2, {});
    }
  | PLUGIN STRING STRING eol
    {
      builder.AddPlugin($2, $3);
    }

/* Anything but a directive. Those constructs apply side-effects to the builder
 * object. */
pragma:
  pushtag
  | poptag
  | pushmeta
  | popmeta
  | option
  | include
  | plugin

/* A rule to reduce pragmas and directives. We also handle errors at this
 * level. */
declarations:
  declarations EOL
  /* Accumulate nothing for anything that's not a directive. The side-effects of
     all those pragma are stored in the builder object. */
  | declarations pragma
  /* A regular directive. Accmulate it in the builder. */
  | declarations directive
    {
      if ($directive != nullptr) {
        // Note: the reference is given to the builder.
        builder.AppendDirective($directive);
      }
    }
  /* An error raised at the parser level. */
  | declarations error
    {
      // TODO(blais): What about the 'error' token encountered elsewhere? Is this
      // guaranteed to bubble up here?
      //
      // TODO(blais): Great place to generically log and error here too?

      // Ignore the error and continue reducing ({3d95e55b654e}). Note that with
      // the matching rule above, "error" will successfully reduce on each line
      // that cannot reduce. Non-erroneous postings after an error occurs will
      // reduce but not be included because a transaction's list of postings
      // does not include an "error" rule.
      //
      // Note: Adding EOL after the "error" rule above works to reduce the
      // number of calls to this rule resulting from the appearance of an error
      // but makes the parser errors skip the next valid directive, so we just
      // have to make sure repeated runs of this rule's handling code are
      // idempotent.
    }
  | %empty

/* Start token for parsing an entire file of the DSL. */
file:
  declarations YYEOF

%%
//- User code ----------------------------------------------------------------

void beancount::parser::Parser::error(const location& loc, const string& msg)
{
  // TODO(blais): Change this code to log an error and bubble that up to the
  // output. We should never write to stderr.
  using std::cerr;
  using std::endl;
  cerr << loc << ": " << msg << endl;
  if (loc.begin.line == loc.end.line && loc.begin.line == scanner.lineno()) {
    cerr << scanner.matcher().line() << endl;
    for (size_t i = 0; i < loc.begin.column; ++i)
      cerr << " ";
    for (size_t i = loc.begin.column; i <= loc.end.column; ++i)
      cerr << "~";
    cerr << endl;
  } else {
    FILE* file = scanner.in().file(); // The current file being scanned.
    if (file != NULL) {
      beancount::scanner::Scanner::Matcher* m = scanner.new_matcher(file);
      scanner.push_matcher(m);
      off_t pos = ftell(file);
      fseek(file, 0, SEEK_SET);
      for (size_t i = 1; i < loc.begin.line; ++i) {
        m->skip('\n'); // Skip to the next line.
      }
      for (size_t i = loc.begin.line; i <= loc.end.line; ++i) {
        cerr << m->line() << endl;
        m->skip('\n'); // Next line.
      }
      fseek(file, pos, SEEK_SET); // Restore position in the file to continue scanning.
      scanner.pop_matcher(); // Restore matcher.
    }
  }

  // If token is unknown (no match).
  if (scanner.size() == 0) {
    scanner.matcher().winput(); // Skip character.
  }
}

namespace beancount {

namespace parser {

Builder::Builder(scanner::Scanner& scanner, PyObject* builder_obj, PyObject* missing_obj) :
  scanner_(scanner),
  builder_obj_(builder_obj),
  missing_obj_(missing_obj)
{
  info_.reset(new options::ProcessingInfo());
  options_.reset(new options::Options());
  assert(builder_obj_ != nullptr);
  assert(missing_obj_ != nullptr);
}

// TODO(blais): Implement builder methods here (maybe).

}  //  namespace parser

namespace scanner {

// An extension to the generated scanner that also fetches the filename for the
// location.
class ScannerWithFile : public scanner::Scanner {
public:
  using scanner::Scanner::Scanner;

  // Set the filename for location tokens.
  void SetFilename(string_view filename) {
    filename_ = filename;
  }

  void SetLineOffset(const int line_offset) {
    line_offset_ = line_offset;
  }

  // Override the location to include the filename.
  // TODO(blais): Why do I need this again?
  beancount::parser::location location() override {
    /* yylloc.begin.line = static_cast<unsigned int>(matcher().lineno()); */
    /* yylloc.begin.column = static_cast<unsigned int>(matcher().columno()); */
    /* yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end()); */
    /* yylloc.end.column = static_cast<unsigned int>(matcher().columno_end()); */
    auto yylloc = scanner::Scanner::location();
    yylloc.begin.filename = &filename_;
    if (line_offset_ > 0) {
      yylloc.begin.line += line_offset_;
      yylloc.end.line += line_offset_;
    }
    return yylloc;
  }

  // TODO(blais): Do we still need this? At least catch the exception.
  virtual void lexer_error(const char* message) override {
    cerr << "Scanner::lexer_error: ";
    if (message) {
      cerr << *message;
    }
    cerr << endl;
    return scanner::Scanner::lexer_error(message);
  }

private:
  string filename_;
  int line_offset_ = 0;
};

}  // namespace scanner

namespace parser {

// TODO(blais): Return the parsed state.
void Parse(PyObject* builder_obj,
           const reflex::Input& input,
           const std::optional<string_view>& filename = {},
           int line_offset = 0,
           PyObject* missing_obj = nullptr) {
  // Create a scanner and builder.
  scanner::ScannerWithFile scanner(input, cout);
  if (filename.has_value()) {
    scanner.SetFilename(filename.value());
  }
  scanner.SetLineOffset(line_offset);
  parser::Builder builder(scanner, builder_obj, missing_obj);

  // Run the parser.
  beancount::parser::Parser parser(scanner, builder);
  parser.set_debug_stream(std::cerr);
  if (getenv("DEBUG")) {
    parser.set_debug_level(1);
  }
  // scanner.set_debug(1);
  try {
    int result = parser.parse();
    (void)result;
  } catch (const std::runtime_error& exc) {
    cerr << "exc " << exc.what() << endl;
  }
}

void ParseFile(PyObject* builder_obj, const string_view& filename, PyObject* missing_obj) {
  std::ifstream in = std::ifstream(string(filename), std::ios::in);
  reflex::Input input(in);
  string filename_str(filename);
  return parser::Parse(builder_obj, input, filename_str, 0, missing_obj);
}

/// std::unique_ptr<proto::Database> ParseString(const string_view& input_string,
///                                              const string_view& filename,
///                                              int line_offset) {
///   // Ensure the string is converted to UTF8 by using reflex::Input and
///   // instantiate a scanner.
///   reflex::Input input(input_string.data(), input_string.size());
///   static const string filename_str(filename);
///   return parser::Parse(input, &filename_str, line_offset);
/// }

/// std::unique_ptr<proto::Database> ParseStdin() {
///   reflex::Input input(stdin, reflex::Input::file_encoding::utf8);
///   static const string filename = "<string>";
///   auto db = parser::Parse(input, &filename);
///   fclose(stdin);
///   return db;
/// }

}  // namespace parser
}  // namespace beancount

// TODO(blais): In v3 review the syntax for uniformity:
// - Allow tags/links on all directives?
// - Remove the EMPTY_SET constraint
// - Make it possible to tag/link before the narration strings.

// TODO(blais): Remove and review all manners of locations() overriding. This
// should normally work fine out of the box, and those fixes are likely
// unnecessary.

// TODO(blais): Rework the rules to take advantage of the name aliases.

// TODO(blais): Carve a dedicated field in the protos for original location
// filename, start line, and end line, doesn't have to be generic metadata.
//
// - In the metadata, output not just the starting line but also the end line,
//   for easy extraction of the original text.

// These can get logged; override the appropriate methods.
// /home/blais/r/q/office/accounting/blais.beancount:1591.2-0x7fff5298fdf8:1591.30: syntax error, unexpected ACCOUNT, expecting DEDENT or TAG or LINK or KEY
//   Assets:CA:LondonLife:RRSP:Cash   2000 CAD
//   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// - Rename `incomplete_amount` -> `partial_amount`

// - Making /all/ directives support tags and links in common would simplify the
//   code and possibly the syntax. Do it.

// - Add templated new/delete interfaces on the builder and count memory
//   allocations.

// - Reorder for all directives to be together.

// - Create a new Ledger container type to expose for producing results, with
//   'directives', 'errors', 'options', 'info' attributes.
