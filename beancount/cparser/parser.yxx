/* -*- mode: c++ -*- */
// Oblique grammar for parser (Bison C++ generator).

//- Options -------------------------------------------------------------------

%require "3.6"

%language "c++"
%define api.namespace {beancount::parser}
%define api.parser.class {Parser}
%define api.value.type variant // See: "C++ Variants"
%define api.token.constructor
%define parse.error detailed
%define parse.trace
%define api.token.prefix {TOK_}
// %verbose, have to specify the output file.
// %token-table // Has no effect on C++ code generation.

%defines
%locations
%define api.filename.type "const std::string"

// %initial-action does not work to set the filename since the location() is set
// on the symbol itself.
// This doesn't work either.
// %initial-action {
//   driver.WithLocation(@$);
// }

// Input state to parser.
%parse-param {::beancount::scanner::Scanner& lexer} {::beancount::parser::Driver& driver}

//- Code blocks ---------------------------------------------------------------

// Inserted in header, before anything else
%code requires {

#include <cstdint>
#include <cstdio>
#include <fstream>
#include <list>
#include <memory>
#include <string>

#include "absl/strings/string_view.h"

namespace beancount {
namespace scanner { class Scanner; }
namespace parser { class Driver; }
typedef absl::string_view strview;

// Example of a local type; do this + below:  %type <TermList*> termlist
///   // Accumulator for term list.
///   struct TermList {
///     // List of word text.
///     std::list<std::string> words;
///
///     // List of yet-to-be-resolved (type, ident) pairs.
///     // Has ownershipo.
///     std::list<proto::Ref*> unresolved_refs;
///   };

}  // namespace beancount
}  // requires

// Inserted in header, at the end.
%code provides {
namespace beancount {

// TODO(blais): Implement these functions below.
/// // Parse contents from the given string.
/// // The 'line_offset' can be used in unit tests to mark the start of the test
/// // string in the parsed file.
/// std::unique_ptr<proto::Database> ParseString(const absl::string_view& input_string,
///                                             const absl::string_view& filename,
///                                             int line_offset = 0);
///
/// // Parse contents from a file.
/// std::unique_ptr<proto::Database> ParseFile(const absl::string_view& filename);
///
/// // Parse contents from stdin.
/// std::unique_ptr<proto::Database> ParseStdin();

}  // namespace beancount
}  // provides

//-----------------------------------------------------------------------------
// Inserted in implementation after including parser header.
%code top {
#include "beancount/cparser/scanner.h"  /* Generated by reflex. */

#include <iostream>
#include <list>
#include <string>
#include <unordered_map>
#include <utility>

#include "absl/container/flat_hash_map.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/string_view.h"
#include "reflex/input.h"

using absl::string_view;
using std::cerr;
using std::cout;
using std::endl;
using std::list;
using std::pair;
using std::string;
using std::unique_ptr;

namespace beancount {
namespace parser {

// In-memory build state for graph of nodes. This driver accepts actions from
// the parser and simply builds up the parsed state. Since the input is not
// assumed to be ordered, resolving references occurs as a separate phase.
class Driver {
public:
  Driver();
  virtual ~Driver();

  // Set the location for errors to occur.
  // This is a stateful setter whose data get used to report errors.
  void WithLocation(const parser::location& location) {
    location_ = location;
  }

  // TODO(blais): Create an updated driver for Beancount.
  //
  /// // Add a new type.
  /// proto::Type* AddType(string_view type, string_view contents,
  ///                      proto::TypeFlavor flavor);
  ///
  /// // Add a new instance of an object node.
  /// proto::Object* AddObject(string_view type,
  ///                          string_view ident,
  ///                          string_view contents);
  ///
  /// // Add a new instance of a lazy object node.
  /// // The identifer is allocated automatically.
  /// proto::Object* AddAutoObject(string_view type,
  ///                              string_view contents) {
  ///
  /// // Add a new instance of an object with default type.
  /// // The identifer is allocated automatically.
  /// proto::Object* AddDefaultObject(string_view contents) {
  ///
  /// // Get the resulting database of objects and clear it.
  /// unique_ptr<proto::Database> GetClearDatabase() {

private:

  // Last registered location.
  parser::location location_;
};

}  // namespace parser
}  // namespace beancount
}  // top

// Inserted in implementation before including parser header
// (Within bison's parse() we should invoke lexer.lex(), not the global yylex().)
%code {
#undef yylex
#define yylex lexer.lex
}

//- Tokens --------------------------------------------------------------------
// Note: Token type names appear in the parser header; qualify fully.

// TODO(blais): Update reserved keywords.
/// /* Reserved keywords. */
/// %token <strview> TYPE
/// %token <strview> LAZYTYPE
/// %token <strview> IGNORE
/// %token MACRO
/// %token IMPORT
///
/// /* End of file. */
/// // %token EOF 0  // Does not have to  get declared explicitly.
///
/// /* Components of body. */
/// %token INDENT;
/// %token EOL;
/// %token <strview> COMMENT
/// %token <proto::Ref*> REF
/// %token <strview> AUTOREF
/// %token <strview> WORD
///
/// // %type <strview> term
/// %type <TermList*> termlist
/// %type <proto::Type*> type_declaration
/// %type <proto::Object*> item_definition
/// %type <proto::Object*> explicit_definition
/// %type <proto::Object*> lazy_definition

//- Grammar rules -------------------------------------------------------------
%%

empty:

%%
//- User code ----------------------------------------------------------------

void beancount::parser::Parser::error(const location& loc, const string& msg)
{
  cerr << loc << ": " << msg << endl;
  if (loc.begin.line == loc.end.line && loc.begin.line == lexer.lineno())
  {
    cerr << lexer.matcher().line() << endl;
    for (size_t i = 0; i < loc.begin.column; ++i)
      cerr << " ";
    for (size_t i = loc.begin.column; i <= loc.end.column; ++i)
      cerr << "~";
    cerr << endl;
  }
  else
  {
    FILE* file = lexer.in().file(); // The current file being scanned.
    if (file != NULL)
    {
      beancount::scanner::Scanner::Matcher* m = lexer.new_matcher(file); // New matcher.
      lexer.push_matcher(m); // Save the current matcher.
      off_t pos = ftell(file); // Save current position in the file.
      fseek(file, 0, SEEK_SET); // Go to the start of the file.
      for (size_t i = 1; i < loc.begin.line; ++i)
        m->skip('\n'); // Skip to the next line.
      for (size_t i = loc.begin.line; i <= loc.end.line; ++i)
      {
        cerr << m->line() << endl; // Display the offending line.
        m->skip('\n'); // Next line.
      }
      fseek(file, pos, SEEK_SET); // Restore position in the file to continue scanning.
      lexer.pop_matcher(); // Restore matcher.
    }
  }
  if (lexer.size() == 0) // If token is unknown (no match).
    lexer.matcher().winput(); // Skip character.
}

namespace beancount {

namespace parser {

Driver::Driver() {
}

Driver::~Driver() {
}

// TODO(blais): Implement driver methods here (maybe).

}  //  namespace parser

namespace scanner {

// An extension to the generated scanner that also fetches the filename for the
// location.
class ScannerWithFile : public scanner::Scanner {
public:
  using scanner::Scanner::Scanner;

  // Set the filename for location tokens.
  void SetFilename(const string* filename) {
    filename_ = filename;
  }

  void SetLineOffset(const int line_offset) {
    line_offset_ = line_offset;
  }

  // Override the location to include the filename.
  beancount::parser::location location() override
  {
    /* yylloc.begin.line = static_cast<unsigned int>(matcher().lineno()); */
    /* yylloc.begin.column = static_cast<unsigned int>(matcher().columno()); */
    /* yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end()); */
    /* yylloc.end.column = static_cast<unsigned int>(matcher().columno_end()); */
    auto yylloc = scanner::Scanner::location();
    if (filename_) {
      yylloc.begin.filename = filename_;
    }
    if (line_offset_ > 0) {
      yylloc.begin.line += line_offset_;
      yylloc.end.line += line_offset_;
    }
    return yylloc;
  }
private:
  const string* filename_ = nullptr;
  int line_offset_ = 0;
};

}  // namespace scanner

namespace parser {

// TODO(blais): Implement parser here.
/// // Parse the given input to a database.
/// std::unique_ptr<proto::Database> Parse(const reflex::Input& input,
///                                        const string* filename = nullptr,
///                                        int line_offset = 0) {
///   // Create a scanner and driver.
///   scanner::ScannerWithFile scanner(input, cout);
///   if (filename != nullptr) {
///     scanner.SetFilename(filename);
///   }
///   scanner.SetLineOffset(line_offset);
///   parser::Driver driver;
///
///   // Run the parser.
///   beancount::parser::Parser parser(scanner, driver);
///   int result = parser.parse();
///   (void)result;
///
///   auto db = driver.GetClearDatabase();
///   return db;
/// }
///
/// }  // namespace parser
///
/// std::unique_ptr<proto::Database> ParseString(const string_view& input_string,
///                                              const string_view& filename,
///                                              int line_offset) {
///   // Ensure the string is converted to UTF8 by using reflex::Input and
///   // instantiate a scanner.
///   reflex::Input input(input_string.data(), input_string.size());
///   static const string filename_str(filename);
///   return parser::Parse(input, &filename_str, line_offset);
/// }
///
/// std::unique_ptr<proto::Database> ParseFile(const string_view& filename) {
///   std::ifstream in = std::ifstream(string(filename), std::ios::in);
///   reflex::Input input(in);
///   string filename_str(filename);
///   return parser::Parse(input, &filename_str);
/// }
///
/// std::unique_ptr<proto::Database> ParseStdin() {
///   reflex::Input input(stdin, reflex::Input::file_encoding::utf8);
///   static const string filename = "<string>";
///   auto db = parser::Parse(input, &filename);
///   fclose(stdin);
///   return db;
/// }

}  // namespace parser

}  // namespace beancount
