/* -*- mode: c++ -*- */
// Scanner definition for Beancount's DSL (with RE/flex).
//
// See RE/flex manual: https://www.genivia.com/doc/reflex/html/

%top{
#include "beancount/cparser/parser.h"    /* Generated by bison. */
#include "beancount/cparser/location.h"  /* Generated by bison %locations. */

#include "beancount/parser/tokens.h"

#include <utility>
#include <cassert>

#include "reflex/matcher.h"
#include "absl/strings/string_view.h"

namespace beancount {

// Using declarations for symbols in the scanner implementation only.
using absl::string_view;
using beancount::parser::Parser;
using std::endl;
using std::string;

inline strview view(const reflex::Matcher& m) {
  return strview(m.begin(), m.size());
}

}  // namespace beancount
}

//- Definitions ---------------------------------------------------------------

// This option generates a ascnner that works with Bison 3.2 C++ complete
// symbols, specified by %define api.value.type variant and %define
// api.token.constructor in a Bison grammar file. This option also sets option
// −−bison-cc and sets −−token-type to the parser's symbol_type, and sets
// −−token-eof to 0, assuming these options are not specified already. Combine
// this option with −−bison-locations to support the Bison %locations feature.
%option bison-complete

// This option generates a scanner that works with Bison with locations enabled.
%option bison-locations

%option bison-cc-namespace=beancount::parser
%option bison-cc-parser=Parser

// Throw an exception in the scanner's default rule.
%option exception="beancount::parser::Parser::syntax_error(location(), \"Unknown token.\")"

%option namespace=beancount::scanner
%option lexer=Scanner

%option tabs=8

// Unicode matching is enabled with %option unicode.
%option unicode

%option indent
%option nodefault

%option fast


// States.
%x INVALID
%x IGNORE

// Patterns for the international components of the names of accounts.
ACCOUNTTYPE     [\p{Lu}][\p{L}\p{Nd}\-]*
ACCOUNTNAME     [\p{Lu}\p{Nd}][\p{L}\p{Nd}\-]*

// Characters that may be used as flags. Make sure to include all the
// values from beancount.core.flags to allow round-trips between text
// and entries. {5307d8fa1e7b}
FLAGS           [!&#?%PSTCURM]

//- Rules ---------------------------------------------------------------------
%%


 /* Newlines matter. */
\n {
   // TODO(blais): Do we still need this? Use the C++ location instead.
   /* yycolumn = 1; */
   return Parser::make_EOL(location());
}

 /* Whitespace: ignored, except when found at the beginning of a line
  * and followed by a regular character. This is how we detect an
  * initial indent and thus group syntax elements in the grammar. */
^[ \t]+/[^ \t\r\n] { return Parser::make_INDENT(view(matcher()), location()); }
[ \t\r]+ { }

 /* Comments. */
;.* { }

 /* Characters with special meanings. */
\|		{ return Parser::make_PIPE(location()); }
@@		{ return Parser::make_ATAT(location()); }
@		{ return Parser::make_AT(location()); }
\{\{		{ return Parser::make_LCURLCURL(location()); }
\}\}		{ return Parser::make_RCURLCURL(location()); }
\{		{ return Parser::make_LCURL(location()); }
\}		{ return Parser::make_RCURL(location()); }
,		{ return Parser::make_COMMA(location()); }
\~		{ return Parser::make_TILDE(location()); }
\+		{ return Parser::make_PLUS(location()); }
\-		{ return Parser::make_MINUS(location()); }
\/		{ return Parser::make_SLASH(location()); }
\(		{ return Parser::make_LPAREN(location()); }
\)		{ return Parser::make_RPAREN(location()); }
\#		{ return Parser::make_HASH(location()); }
\*		{ return Parser::make_ASTERISK(location()); }
\:		{ return Parser::make_COLON(location()); }

{FLAGS} {
  return Parser::make_FLAG(wchr(), location());
}

 /* Keywords. */
txn		{ return Parser::make_TXN(location()); }
balance		{ return Parser::make_BALANCE(location()); }
open		{ return Parser::make_OPEN(location()); }
close		{ return Parser::make_CLOSE(location()); }
commodity	{ return Parser::make_COMMODITY(location()); }
pad		{ return Parser::make_PAD(location()); }
event		{ return Parser::make_EVENT(location()); }
query		{ return Parser::make_QUERY(location()); }
custom		{ return Parser::make_CUSTOM(location()); }
price		{ return Parser::make_PRICE(location()); }
note		{ return Parser::make_NOTE(location()); }
document	{ return Parser::make_DOCUMENT(location()); }
pushtag	        { return Parser::make_PUSHTAG(location()); }
poptag		{ return Parser::make_POPTAG(location()); }
pushmeta	{ return Parser::make_PUSHMETA(location()); }
popmeta		{ return Parser::make_POPMETA(location()); }
option		{ return Parser::make_OPTION(location()); }
plugin		{ return Parser::make_PLUGIN(location()); }
include		{ return Parser::make_INCLUDE(location()); }

TRUE {
  Py_INCREF(Py_True);
  return Parser::make_BOOL(Py_True, location());
}

FALSE {
  Py_INCREF(Py_False);
  return Parser::make_BOOL(Py_False, location());
}

NULL {
  Py_INCREF(Py_None);
  return Parser::make_NONE(Py_None, location());
}

 /* Dates. */
[0-9]{4,}[\-/][0-9]+[\-/][0-9]+ {
  return Parser::make_DATE(build_DATE(text()), location());
}

 /* Account names. */
{ACCOUNTTYPE}(:{ACCOUNTNAME})+ {
  return Parser::make_ACCOUNT(build_ACCOUNT(text()), location());
}

 /* Currencies. These are defined as uppercase only in order to
  * disambiguate the syntax. This is to be kept in sync with
  * beancount.core.amount.CURRENCY_RE. */
[A-Z][A-Z0-9\'\.\_\-]{0,22}[A-Z0-9] {
  return Parser::make_CURRENCY(build_CURRENCY(matcher().begin(), matcher().size()),
                               location());
}

 /* String literals. */
\"([^\\\"]|\\.)*\" {
  // TODO(blais): Add state to the scanner for specific encoding.
  static const char* encoding = "UTF-8";
    return Parser::make_STRING(
      build_STRING(matcher().begin()+1, matcher().size()-2, encoding),
      location());
}

 /* Numbers. */
([0-9]+|[0-9][0-9,]+[0-9])(\.[0-9]*)? {
  return Parser::make_NUMBER(build_NUMBER(text()), location());
}

 /* Tags. */
#[A-Za-z0-9\-_/.]+ {
return Parser::make_TAG(build_TAG(matcher().begin()+1, matcher().size()-1),
                        location());
}

 /* Links. */
\^[A-Za-z0-9\-_/.]+ {
  return Parser::make_LINK(build_LINK(matcher().begin()+1, matcher().size()-1),
                           location());
}

 /* Keys. */
[a-z][a-zA-Z0-9\-_]+/: {
  return Parser::make_KEY(build_KEY(matcher().begin(), matcher().size()),
                          location());
}

 /* Lines starting with an asterisk, a colon, an hash, or a character
  * in the FLAGS characters set are ignored. This rule is inserted
  * here to give higher precedence to rules matching valid tokens. */
^[\*\:\#]/.	{ start(IGNORE); }
^{FLAGS}/.	{ start(IGNORE); }

 /* Default rule. {bf253a29a820} */
. {
  matcher().unput(*text());
  start(INVALID);
}

<<EOF>> {
  /* Ensure location data is populated. */
  // TODO(blais): Review this, how to handle in RE/flex.
  /// YY_USER_ACTION;
  return Parser::make_YYEOF(location());
}

 /* Invalid input: skip over to to the next whitespace character. */
<INVALID>[^ \t\n\r]+ {
  PyObject* input = PyUnicode_Decode(matcher().begin(), matcher().size(),
                                     "utf-8", "backslashreplace");
  // TODO(blais): Issue error the C++ way
#if 0
  build_lexer_error(yylloc, builder, "Invalid token: '%U'", input);
#endif
  start(INITIAL);

  // Return special error token generated by Bison.
  return Parser::make_YYerror(location());
}
 /* Ignore input till the newline. */
<IGNORE>.* {
    start(INITIAL);
}


%%

//-----------------------------------------------------------------------------
// Code: Scanner Body
